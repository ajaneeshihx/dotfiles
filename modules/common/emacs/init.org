#+PROPERTY: header-args :tangle ~/.emacs.d/init.el :tangle-dir "~/.emacs.d/"

* Start server process

this is now running as a systemd service

#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
(message "Loading: Server Process")

(require 'server)
(unless (server-running-p)
  (server-start))

(message "Completed: Server Process")
#+end_src

* Startup performance

#+begin_src emacs-lisp
(message "Loading: Startup Performance")

  ;; 1. Performance Improvements
  (defun my/restore-gc-threshold ()
    "Restore garbage collection threshold after startup."
    (setq gc-cons-threshold (* 2 1000 1000)))  ; 2MB

  (add-hook 'emacs-startup-hook #'my/restore-gc-threshold)

  ;; Silence compiler warnings as they can be pretty disruptive
  (setq native-comp-async-report-warnings-errors nil)

  ;; Set the right directory to store the native comp cache
  (add-to-list 'native-comp-eln-load-path (expand-file-name "eln-cache/" user-emacs-directory))

  ;; Suppress byte-compilation warnings for third-party packages
  (setq byte-compile-warnings '(not obsolete docstrings unused lexical free-vars unresolved))
  (setq warning-suppress-log-types '((comp) (bytecomp)))

  ;; Auto save and backup settings
  (setq
   backup-by-copying t
   backup-directory-alist '(("." . "~/.emacs.d/backups"))
   delete-old-versions t
   kept-new-versions 6
   kept-old-versions 2
   version-control t)

(message "Completed: Startup Performance")
#+end_src

* Some required packages

#+begin_src emacs-lisp

(use-package treemacs-all-the-icons
  :ensure nil)

(use-package which-key
  :ensure nil
  :config
  (which-key-mode))

;; High-impact productivity packages
(use-package avy 
  :ensure nil
  :bind (("C-;" . avy-goto-char-timer)
         ("M-g f" . avy-goto-line)
         ("M-g w" . avy-goto-word-1))
  :config
  (setq avy-timeout-seconds 0.5))

(use-package multiple-cursors 
  :ensure nil
  :bind (("C-S-c C-S-c" . mc/edit-lines)
         ("C->" . mc/mark-next-like-this)
         ("C-<" . mc/mark-previous-like-this)
         ("C-c C-<" . mc/mark-all-like-this)))

(use-package helpful 
  :ensure nil
  :bind (("C-h f" . helpful-callable)
         ("C-h v" . helpful-variable)
         ("C-h k" . helpful-key)
         ("C-h x" . helpful-command)))

(use-package diff-hl 
  :ensure nil
  :hook (prog-mode . diff-hl-mode)
  :hook (magit-pre-refresh . diff-hl-magit-pre-refresh)
  :hook (magit-post-refresh . diff-hl-magit-post-refresh)
  :config
  (diff-hl-flydiff-mode))

;; Window configuration undo/redo (built-in)
(use-package winner
  :ensure nil
  :config 
  (winner-mode 1)
  (global-set-key (kbd "C-c <left>") 'winner-undo)
  (global-set-key (kbd "C-c <right>") 'winner-redo))

;; Recent files (built-in)
(use-package recentf
  :ensure nil
  :config
  (setq recentf-max-menu-items 25
        recentf-max-saved-items 100)
  (recentf-mode 1))

;; Startup dashboard
(use-package dashboard 
  :ensure nil
  :config
  (dashboard-setup-startup-hook)
  (setq dashboard-startup-banner 'logo
        dashboard-center-content t
        dashboard-items '((recents . 10)
                         (projects . 5)
                         (bookmarks . 5))
        dashboard-set-heading-icons t
        dashboard-set-file-icons t))

;; Visual improvements
(use-package rainbow-mode 
  :ensure nil
  :hook prog-mode)

(use-package highlight-indent-guides 
  :ensure nil
  :hook prog-mode
  :config
  (setq highlight-indent-guides-method 'bitmap))

(use-package ligature
  :ensure nil)

(use-package pyvenv
  :ensure nil)

(use-package all-the-icons
  :ensure nil)

(use-package treemacs-all-the-icons
  :ensure nil)

(use-package htmlize
  :ensure nil)

#+end_src

* SSH Tunnel Configuration (need external library that uses pem key and secrets)
** TODO This is only for the ssh tunneling.  I need to turn this into a module that can be loaded from git.  Having it in this folder will mean that it cannot be made available to others in a reproducible fashion

#+begin_src emacs-lisp

  ;; Add my library path to load-path
  (push "~/lib/elisp/" load-path)

#+end_src

** Need to externalize secrets and put this in a github repo as a package so that this can be loaded from other machines without having to copy it around

#+begin_src emacs-lisp

  (require 'ssh-tunnel-manager)

  ;; Optional: setup default keybindings
  (ssh-tunnel-setup-default-keybindings)


#+end_src

* Basic UI Configuration

#+begin_src emacs-lisp

  (setq inhibit-startup-message t)

  (scroll-bar-mode -1)        ; Disable visible scrollbar
  (tool-bar-mode -1)          ; Disable the toolbar
  (tooltip-mode -1)           ; Disable tooltips
  (set-fringe-mode 10)        ; Give some breathing room

  (menu-bar-mode -1)            ; Disable the menu bar

  ;; Set up the visible bell
  (setq visible-bell t)

  (column-number-mode)
  ;; (global-display-line-numbers-mode t)
  (global-hl-line-mode 1)

  ;; Set frame transparency
  ;; (set-frame-parameter (selected-frame) 'alpha efs/frame-transparency)
  ;; (add-to-list 'default-frame-alist `(alpha . ,efs/frame-transparency))
  ;; (set-frame-parameter (selected-frame) 'fullscreen 'maximized)
  ;; (add-to-list 'default-frame-alist '(fullscreen . maximized))

  ;;
  ;; Disable line numbers for some modes
  (dolist (mode '(org-mode-hook
                  term-mode-hook
                  shell-mode-hook
                  treemacs-mode-hook
                  eshell-mode-hook))
    (add-hook mode (lambda () (display-line-numbers-mode 0))))

  (setq make-backup-files nil) ; stop creating backup~ files
  (setq auto-save-default nil) ; stop creating #autosave# files
  (setq cider-save-file-on-load nil)

  ;; 7. Better Window Management
  (use-package windmove
    :ensure nil
    :config
    (windmove-default-keybindings 'super))

  ;; Ace-window - for more complex window management
  (use-package ace-window
    :ensure nil
    :bind (("M-o" . ace-window))
    :custom
    (aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l)) ; Use letters instead of numbers
    :config
    (ace-window-display-mode 1)) ; Optionally show persistent window labels

#+end_src

* Get =evil-mode= up and running ASAP so that we dont have to struggle with emacs editing controls

#+begin_src emacs-lisp
(message "Loading: Evil Mode Configuration")

    (use-package undo-tree
      :ensure nil
      :config
      (setq undo-tree-auto-save-history nil)
      (global-undo-tree-mode 1))


    (use-package evil
      :init
      (setq evil-want-integration t)
      (setq evil-want-keybinding nil)
      (setq evil-want-C-u-scroll nil)
      (setq evil-want-C-i-jump nil)
      (setq evil-respect-visual-line-mode t)
      (setq evil-undo-system 'undo-tree)

      :config
      (evil-mode 1)

      ;; Set Emacs state modes
      (dolist (mode '(custom-mode
                      eshell-mode
                      git-rebase-mode
                      erc-mode
                      circe-server-mode
                      circe-chat-mode
                      circe-query-mode
                      sauron-mode
                      term-mode))
        (add-to-list 'evil-emacs-state-modes mode))

      (define-key evil-insert-state-map (kbd "C-g") 'evil-normal-state)
      (define-key evil-insert-state-map (kbd "C-h") 'evil-delete-backward-char-and-join)
      ;; (define-key evil-normal-state-map (kbd "C-<left>") 'backward-word)
      ;; (define-key evil-normal-state-map (kbd "C-<right>") 'forward-word)
      ;; Clear the binding of C-k so that it doesn't conflict with Corfu
      (define-key evil-insert-state-map (kbd "C-k") nil)

      ;; Use visual line motions even outside of visual-line-mode buffers
      (evil-global-set-key 'motion "j" 'evil-next-visual-line)
      (evil-global-set-key 'motion "k" 'evil-previous-visual-line)
      (evil-set-initial-state 'messages-buffer-mode 'normal)
      (evil-set-initial-state 'dashboard-mode 'normal))

    (use-package evil-collection
      :after evil
      :ensure nil
      :config
      (evil-collection-init '(not python)))

    ;; Example: ysiw"  surround word with quotes
    ;;          ds"    delete surrounding quotes
    ;;          cs'   change surrounding quotes to single quotes
    (use-package evil-surround
      :ensure nil
      :config
      (global-evil-surround-mode 1))

    (use-package evil-commentary
    :ensure nil
    :config
    (evil-commentary-mode))

    ;; Visual feedback for evil operations
    (use-package evil-goggles 
      :ensure nil
      :after evil
      :config 
      (evil-goggles-mode)
      (setq evil-goggles-duration 0.200))

    ;; Search count display
    (use-package evil-anzu 
      :ensure nil
      :after evil
      :config 
      (global-anzu-mode))

      (use-package evil-matchit
      :ensure nil
      :config
      (global-evil-matchit-mode 1))

(use-package expand-region
  :ensure nil
  :config
  ;; Define for all programming modes
  (define-key prog-mode-map (kbd "C-{") 'er/expand-region)
  
  ;; If using Evil, add Evil bindings for all programming modes
  (evil-define-key '(normal visual) prog-mode-map
    (kbd "C-{") 'er/expand-region))


    ;; Org block navigation
    (with-eval-after-load 'org
      (define-key org-mode-map (kbd "C-c n") #'org-next-block)
      (define-key org-mode-map (kbd "C-c p") #'org-previous-block) )

(message "Completed: Evil Mode Configuration")
#+end_src

* Python configuration

#+begin_src emacs-lisp
(message "Loading: Python Configuration")

;; Remove ELPA python package from load path
(setq load-path 
      (cl-remove-if
       (lambda (path)
         (string-match-p "python-0\\.28" path))
       load-path))

;; Force load the built-in python.el first
;; (load "/nix/store/ypkhlc24d7skgal25f58bnnbp9rp49li-emacs-29.4/share/emacs/29.4/lisp/progmodes/python")

;; TreeSit and Python configuration
(message "Loading: TreeSitter Configuration")
(use-package treesit
  :ensure nil
  :config
  (setq treesit-language-source-alist
        '((python "https://github.com/tree-sitter/tree-sitter-python")
          (javascript "https://github.com/tree-sitter/tree-sitter-javascript")
          (typescript "https://github.com/tree-sitter/tree-sitter-typescript" "master" "typescript/src")
          (tsx "https://github.com/tree-sitter/tree-sitter-typescript" "master" "tsx/src")
          (yaml "https://github.com/tree-sitter-grammars/tree-sitter-yaml")
          (json "https://github.com/tree-sitter/tree-sitter-json")
          (css "https://github.com/tree-sitter/tree-sitter-css")
          (html "https://github.com/tree-sitter/tree-sitter-html")
          (bash "https://github.com/tree-sitter/tree-sitter-bash")
          (dockerfile "https://github.com/camdencheek/tree-sitter-dockerfile")
          (toml "https://github.com/tree-sitter/tree-sitter-toml")))

  (when (treesit-available-p)
    ;; Install grammar if needed
    (unless (treesit-language-available-p 'python)
      (treesit-install-language-grammar 'python))
    (unless (treesit-language-available-p 'javascript)
      (treesit-install-language-grammar 'javascript))
    (unless (treesit-language-available-p 'typescript)
      (treesit-install-language-grammar 'typescript))
    (unless (treesit-language-available-p 'tsx)
      (treesit-install-language-grammar 'tsx))
    (unless (treesit-language-available-p 'yaml)
      (treesit-install-language-grammar 'yaml))
    (unless (treesit-language-available-p 'json)
      (treesit-install-language-grammar 'json))
    (unless (treesit-language-available-p 'css)
      (treesit-install-language-grammar 'css))
    (unless (treesit-language-available-p 'html)
      (treesit-install-language-grammar 'html))
    (unless (treesit-language-available-p 'bash)
      (treesit-install-language-grammar 'bash))
    (unless (treesit-language-available-p 'dockerfile)
      (treesit-install-language-grammar 'dockerfile))
    (unless (treesit-language-available-p 'toml)
      (treesit-install-language-grammar 'toml))
    
    ;; Set up python-ts-mode
    (defvar python-ts-mode-map (make-sparse-keymap))
    (add-to-list 'major-mode-remap-alist
                 '(python-mode . python-ts-mode))
    (add-to-list 'auto-mode-alist '("\\.py\\'" . python-ts-mode))
    
    ;; Set up yaml-ts-mode
    (add-to-list 'major-mode-remap-alist
                 '(yaml-mode . yaml-ts-mode))
    (add-to-list 'auto-mode-alist '("\\.ya?ml\\'" . yaml-ts-mode))
    
    ;; Set up json-ts-mode  
    (add-to-list 'major-mode-remap-alist
                 '(json-mode . json-ts-mode))
    (add-to-list 'auto-mode-alist '("\\.json\\'" . json-ts-mode))
    
    ;; Set up JavaScript/TypeScript treesitter modes
    (add-to-list 'major-mode-remap-alist
                 '(js2-mode . js-ts-mode))
    (add-to-list 'major-mode-remap-alist
                 '(typescript-mode . typescript-ts-mode))
    (add-to-list 'auto-mode-alist '("\\.js\\'" . js-ts-mode))
    (add-to-list 'auto-mode-alist '("\\.ts\\'" . typescript-ts-mode))
    
    ;; Set up other treesitter modes
    (add-to-list 'major-mode-remap-alist
                 '(css-mode . css-ts-mode))
    (add-to-list 'major-mode-remap-alist
                 '(dockerfile-mode . dockerfile-ts-mode))
    (add-to-list 'major-mode-remap-alist
                 '(toml-mode . toml-ts-mode))
    (add-to-list 'auto-mode-alist '("\\.css\\'" . css-ts-mode))
    (add-to-list 'auto-mode-alist '("Dockerfile\\'" . dockerfile-ts-mode))
    (add-to-list 'auto-mode-alist '("\\.toml\\'" . toml-ts-mode))))

(message "Completed: TreeSitter Configuration")

;; Use Eglot (built-in) instead of lsp-mode for better compatibility
(message "Loading: LSP Configuration - Eglot")
(use-package eglot
  :ensure nil
  :hook ((python-ts-mode . eglot-ensure)
         (yaml-mode . eglot-ensure)
         (yaml-ts-mode . eglot-ensure)
         (js-ts-mode . eglot-ensure)
         (typescript-ts-mode . eglot-ensure)
         (css-ts-mode . eglot-ensure))
  :config
  ;; Configure pylsp to use project virtual environment
  (defun my/eglot-pylsp-venv-command ()
    "Get pylsp command using project virtual environment if available."
    (let ((venv-pylsp (expand-file-name ".venv/bin/pylsp" (project-root (project-current)))))
      (if (file-exists-p venv-pylsp)
          (list venv-pylsp)
        '("pylsp"))))
  
  ;; Use project-specific pylsp if available, fallback to system
  (add-to-list 'eglot-server-programs 
               '(python-ts-mode . my/eglot-pylsp-venv-command))
  
  ;; Add YAML language server support
  (add-to-list 'eglot-server-programs
               '((yaml-mode yaml-ts-mode) . ("yaml-language-server" "--stdio")))
  
  ;; Add CSS language server support (from vscode-langservers-extracted)
  (add-to-list 'eglot-server-programs
               '(css-ts-mode . ("vscode-css-language-server" "--stdio")))
  
  ;; Configure pylsp settings
  (setq-default eglot-workspace-configuration
                '((:pylsp . (:plugins (:pycodestyle (:enabled t))
                                     (:mccabe (:enabled nil))
                                     (:pyflakes (:enabled t))
                                     (:flake8 (:enabled t))
                                     (:autopep8 (:enabled nil))
                                     (:yapf (:enabled t)))))))

(message "Completed: LSP Configuration - Eglot")

;; Development tools
(message "Loading: Python Development Tools")
(use-package python-black
  :after python
  :hook (python-ts-mode . python-black-on-save-mode))

(use-package py-isort
  :hook (python-ts-mode . py-isort-before-save))

;; Enhanced Python development tools
(use-package poetry 
  :ensure nil
  :hook (python-ts-mode . poetry-tracking-mode))

(use-package ein 
  :ensure nil
  :config
  (setq ein:output-area-inlined-images t))

(use-package dap-mode 
  :ensure nil
  :config 
  (dap-auto-configure-mode)
  (require 'dap-python))

;; Environment Management
(use-package pyvenv
  :config
  (pyvenv-mode 1))

;; Initialize evil-collection for python after everything is set up
(with-eval-after-load 'evil-collection
  (when (treesit-available-p)
    (evil-collection-init '(python))))



;; Python development keybindings
(add-hook 'python-ts-mode-hook
	  (lambda ()
	    (let ((map python-ts-mode-map))
	      (define-key map (kbd "C-c C-f") 'python-black-buffer)
	      (define-key map (kbd "C-c C-i") 'py-isort-buffer)
	      (define-key map (kbd "C-c d") 'eldoc-doc-buffer)  ; Show documentation
	      (define-key map (kbd "C-c C-d") 'xref-find-definitions)  ; Eglot uses xref
	      (define-key map (kbd "C-c C-r") 'xref-find-references)   ; Eglot uses xref
	      (define-key map (kbd "M-.") 'xref-find-definitions)      ; Standard Emacs binding
	      (define-key map [f3] 'xref-find-definitions)             ; Your F3 binding
	      (define-key map [f4] 'xref-find-references)              ; Your F4 binding  
	      (define-key map [M-left] 'xref-go-back))))


;; Override Evil keybindings for Python
(with-eval-after-load 'evil
  (evil-define-key '(normal insert visual) python-ts-mode-map 
    (kbd "C-.") 'embark-act
    (kbd "M-.") 'lsp-find-definition
    (kbd "M-,") 'xref-go-back))

#+end_src

#+RESULTS:

* =org-mode= base configuration

#+begin_src emacs-lisp
(message "Loading: Org Mode - Base Configuration")

;; TODO: Mode this to another section
(setq-default fill-column 80)

;; Org-mode specific settings
(use-package org
  :ensure nil
  :custom
  (org-startup-indented t)
  (org-startup-folded t)
  (org-log-done 'time)
  (org-agenda-start-on-weekday nil)
  (org-hide-emphasis-markers t)
  (org-fontify-quote-and-verse-blocks t)
  (org-fontify-whole-heading-line t)
  (org-hide-leading-stars t)
  (org-pretty-entities t)
  (org-ellipsis "…")
  )

(use-package org-superstar
  :ensure nil
  :after org
  :hook (org-mode . org-superstar-mode)
  :custom
  (org-superstar-headline-Bullets-list '("◉" "○" "●" "○" "●" "○" "●")))

;; Enhanced org-mode features
(use-package org-bullets 
  :ensure nil
  :hook (org-mode . org-bullets-mode))

(use-package org-download 
  :ensure nil
  :hook (org-mode . org-download-enable)
  :config
  (setq org-download-method 'directory
        org-download-image-dir "images"))

(use-package ob-restclient 
  :ensure nil
  :after org
  :config
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((restclient . t)
     (emacs-lisp . t)
     (python . t)
     (shell . t))))

;; This is needed as of Org 9.2
;; Fix org-tempo template expansion
(with-eval-after-load 'org-tempo
  ;; Clear and redefine the structure templates
  (setq org-structure-template-alist nil)
  
  ;; Add templates WITHOUT the tangle parameter
  (add-to-list 'org-structure-template-alist '("sh" . "src sh"))
  (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist '("li" . "src lisp"))
  (add-to-list 'org-structure-template-alist '("sc" . "src scheme"))
  (add-to-list 'org-structure-template-alist '("ts" . "src typescript"))
  (add-to-list 'org-structure-template-alist '("py" . "src python"))
  (add-to-list 'org-structure-template-alist '("go" . "src go"))
  (add-to-list 'org-structure-template-alist '("yaml" . "src yaml"))
  (add-to-list 'org-structure-template-alist '("json" . "src json"))
  
  ;; Fix the left angle bracket issue
  (advice-add 'org-tempo-add-block :around
              (lambda (orig-fun &rest args)
                "Remove the < character before inserting a block."
                (when (looking-back "<" 1)
                  (delete-char -1))
                (apply orig-fun args))))

(with-eval-after-load 'org
  (setq org-src-preserve-indentation nil)
  (setq org-edit-src-content-indentation 0)
  (setq org-src-tab-acts-natively t))

(setq org-agenda-files '("~/org" "~/org/roam"))

(with-eval-after-load 'evil
    (evil-define-key '(normal insert) org-mode-map
      (kbd "S-<right>") 'org-shiftright))
#+end_src

* =org-roam= and =org-ui= configuration

#+begin_src emacs-lisp 

(use-package org-roam
  :ensure nil
  :custom
  (org-roam-directory (file-truename "~/org/roam/")) ;; Set your preferred directory
  (org-roam-completion-everywhere t)
  (org-roam-capture-templates
   '(("d" "default" plain
      "%?"
      :if-new (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
      :unnarrowed t)))
  :bind (("C-c n l" . org-roam-buffer-toggle)
         ("C-c n f" . org-roam-node-find)
         ("C-c n i" . org-roam-node-insert)
         :map org-mode-map
         ("C-M-i" . completion-at-point))
  :config
  (org-roam-db-autosync-mode))

(use-package org-roam-ui
  :after org-roam
  :custom
  (org-roam-ui-sync-theme t)
  (org-roam-ui-follow t)
  (org-roam-ui-update-on-save t)
  (org-roam-ui-open-on-start nil) ;; Changed to nil to avoid opening automatically
  :config
  ;; Ensure we load the server
  (defun my/org-roam-ui-open ()
    "Ensure the server is active, then open the roam graph."
    (interactive)
    (unless org-roam-ui-mode
      (org-roam-ui-mode))
    (org-roam-ui-open))
  
  ;; Add a key binding
  (global-set-key (kbd "C-c n g") 'my/org-roam-ui-open))

#+end_src

* =org-mode= wrapping
** Automatic wrapping: Enable auto-fill-mode for automatic wrapping as you type:

#+begin_src emacs-lisp
  ;; (add-hook 'org-mode-hook 'auto-fill-mode)
#+end_src
  
** Visual wrapping (doesn't modify text, just displays it wrapped):

#+begin_src emacs-lisp
  ;; (add-hook 'org-mode-hook 'visual-line-mode)
#+end_src

** Auto wrap to window size

#+begin_src emacs-lisp

  (defun my/set-org-visual-wrap ()
    "Enable visual line wrapping for org-mode."
    (visual-line-mode 1)             
    (setq word-wrap t)               
    (setq truncate-lines nil))       

    (add-hook 'org-mode-hook 'my/set-org-visual-wrap)
  
#+end_src

* =org-mode= workflow customization
** Org Agenda Custom View
#+begin_src emacs-lisp

;; Org Agenda Custom Views
(setq org-agenda-custom-commands
      '(("d" "Daily Dashboard"
         ((agenda "" ((org-agenda-span 'day)
                      (org-agenda-start-day ".")
                      (org-agenda-start-on-weekday nil)))
          (tags-todo "+PRIORITY=\"A\"" 
                     ((org-agenda-overriding-header "High Priority Tasks")))
          (todo "IN-PROGRESS" 
                ((org-agenda-overriding-header "In Progress")))
          (todo "WAITING" 
                ((org-agenda-overriding-header "Waiting For")))
          (todo "NEXT" 
                ((org-agenda-overriding-header "Next Actions")))
          (tags "standup" 
                ((org-agenda-overriding-header "Standup Notes")))))
        
        ("w" "Work Tasks" tags-todo "work"
         ((org-agenda-overriding-header "Work Tasks")
          (org-agenda-files '("~/org/work.org"))))
        
        ("p" "Projects Overview" 
         ((tags-todo "project+LEVEL=2"
                     ((org-agenda-overriding-header "Active Projects")))))
        
        ("r" "Weekly Review"
         ((agenda "" ((org-agenda-span 'week)
                      (org-agenda-start-on-weekday 1)
                      (org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
                      (org-agenda-start-with-log-mode '(closed clock state))))
          (tags "CLOSED>=\"<-7d>\""
                ((org-agenda-overriding-header "Completed Last Week")))))))

#+end_src
** Task States and Workflow
#+begin_src emacs-lisp

(setq org-todo-keywords
      '((sequence "TODO(t/!)" "NEXT(n/!)" "IN-PROGRESS(p@/!)" "WAITING(w/!)" "|" "DONE(d@/!)" "CANCELLED(c@/!)")
        (sequence "IDEA(i)" "DRAFT(d)" "IN-REVIEW(r)" "|" "PUBLISHED(b)")))

;; Set TODO state colors
(setq org-todo-keyword-faces
      '(("TODO" . org-warning)
        ("NEXT" . (:foreground "blue" :weight bold))
        ("IN-PROGRESS" . (:foreground "orange" :weight bold))
        ("WAITING" . (:foreground "purple" :weight bold))
        ("DONE" . (:foreground "green" :weight bold))
        ("CANCELLED" . (:foreground "gray" :weight bold))
        ("IDEA" . (:foreground "gold" :weight bold))
        ("DRAFT" . (:foreground "cyan" :weight bold))
        ("IN-REVIEW" . (:foreground "tomato" :weight bold))
        ("PUBLISHED" . (:foreground "forest green" :weight bold))))
#+end_src
** Logbook and Tracking Changes
#+begin_src emacs-lisp
;; Extensive logging configuration
(setq org-log-done 'time
      org-log-into-drawer t
      org-log-state-notes-into-drawer t
      org-log-repeat 'time
      org-log-redeadline 'note
      org-log-reschedule 'note
      org-log-note-clock-out t
      org-log-done-with-time t)

;; Enable logging of when items are rescheduled or redeadlined
(setq org-treat-insert-todo-heading-as-state-change t)
#+end_src
** Org Capture Templates
#+begin_src emacs-lisp 
(setq org-capture-templates
      '(("e" "Email" entry (file+headline "~/org/mail.org" "Emails")
         "* TODO %:subject\nSCHEDULED: %t\n%a\n%i\n%?")
	
        ("r" "Email Reply" entry (file+headline "~/org/mail.org" "Replies")
         "* TODO Reply to %:fromname on %:subject\nSCHEDULED: %t\n%a\n%i\n%?")
	
        ("f" "Email Follow-up" entry (file+headline "~/org/mail.org" "Follow-ups")
         "* TODO Follow up with %:fromname\nSCHEDULED: %<+3d>\n%a\n%i\n%?")

        ("t" "Task" entry (file+headline "~/org/tasks.org" "Inbox")
         "* TODO %?\n%U\n%a\n")
        
        ("s" "Standup Note" entry (file+olp+datetree "~/org/standups.org")
         "* %U %?\n%^{Status|Done|In Progress|Planned}:\n%^{Details}\n" :tree-type week)
        
        ("m" "Meeting" entry (file+headline "~/org/meetings.org" "Meetings")
         "* %^{Meeting Title} :meeting:\n%U\n** Attendees\n%^{Attendees}\n** Notes\n%?\n** Action Items\n")
        
        ("j" "Journal" entry (file+olp+datetree "~/org/journal.org")
         "* %?\nEntered on %U\n")
        
        ("i" "Idea" entry (file+headline "~/org/ideas.org" "Ideas")
         "* IDEA %?\n%U\n")
        
        ("p" "Project" entry (file+headline "~/org/projects.org" "Projects")
         "* %^{Project Name} [/] :project:\n%U\n** Description\n%^{Project Description}\n** Tasks\n*** TODO %?")))
#+end_src
** Daily Notes (Journaling)
#+begin_src emacs-lisp
;; Dailies configuration using org-roam-dailies
(use-package org-roam-dailies
  :after org-roam
  :config
  (setq org-roam-dailies-directory "daily/")
  (setq org-roam-dailies-capture-templates
        '(("d" "default" entry
           "* %?"
           :target (file+head "%<%Y-%m-%d>.org"
                              "#+title: %<%Y-%m-%d>\n#+filetags: daily\n\n* Tasks\n\n* Notes\n\n* Journal\n")))))

;; Key bindings for dailies
(define-key global-map (kbd "C-c n d") 'org-roam-dailies-goto-today)
(define-key global-map (kbd "C-c n y") 'org-roam-dailies-goto-yesterday)
(define-key global-map (kbd "C-c n t") 'org-roam-dailies-goto-tomorrow)
(define-key global-map (kbd "C-c n c") 'org-roam-dailies-capture-today)
#+end_src
** Tag System for Better Organization
#+begin_src emacs-lisp 
;; Set up standard tags
(setq org-tag-alist '((:startgroup)
                      ("@work" . ?w) ("@home" . ?h) ("@errands" . ?e)
                      (:endgroup)
                      ("standup" . ?s)
                      ("meeting" . ?m)
                      ("project" . ?p)
                      ("idea" . ?i)
                      ("urgent" . ?u)
                      ("followup" . ?f)))

;; Fast tag selection
(setq org-fast-tag-selection-single-key t)
#+end_src
** Advanced Workflow for standups
#+begin_src emacs-lisp :tangle yes
;; Define team members
(defvar my/team-members '("Dev1" "Dev2" "Dev3" "Dev4" "DevOps" "QA"))

;; Function to assign team members with completion
(defun my/assign-team-members ()
  "Prompt for team members and add them to the ASSIGNED property."
  (interactive)
  (let* ((selected (completing-read-multiple 
                    "Assign to (comma-separated): " 
                    my/team-members))
         (assigned (mapconcat 'identity selected ", ")))
    (org-set-property "ASSIGNED" assigned)))

;; Bind to a convenient key
(define-key org-mode-map (kbd "C-c a") 'my/assign-team-members)

;; Create a standup-specific agenda view
(add-to-list 'org-agenda-custom-commands
             '("S" "Standup Overview"
               ((agenda "" ((org-agenda-span 'day)
                            (org-agenda-start-day ".")
                            (org-deadline-warning-days 14)))
                (tags-todo "DEADLINE<\"<now>\"|SCHEDULED<\"<now>\""
                           ((org-agenda-overriding-header "Overdue Tasks")))
                (todo "WAITING" 
                      ((org-agenda-overriding-header "Blocked Tasks")))
                (todo "IN-PROGRESS" 
                      ((org-agenda-overriding-header "In Progress")))
                (todo "NEXT" 
                      ((org-agenda-overriding-header "Starting Soon")
                       (org-agenda-skip-function '(org-agenda-skip-entry-if 'notscheduled))))
                (todo "TODO"
                      ((org-agenda-overriding-header "Upcoming \(Next 14 Days\)")
                       (org-agenda-skip-function 
			'(org-agenda-skip-entry-if 
                          'notscheduled 
                          '(not (org-agenda-skip-subtree-if 
				 'scheduled 
				 '(lambda () (org-get-scheduled-time (point))
                                    (> 14 (org-time-stamp-to-now
                                           (org-get-scheduled-time (point))))))))))))))
;; Make notes appear similar to state changes (timestamp at end)
(setq org-log-note-headings '((done . "CLOSING NOTE %t")
                              (state . "State %-12s from %-12S %t")
                              (note . "Note %t")
                              (reschedule . "Rescheduled from %S on %t")
                              (delschedule . "Not scheduled, was %S on %t")
                              (redeadline . "New deadline from %S on %t")
                              (deldeadline . "Removed deadline, was %S on %t")
                              (refile . "Refiled on %t")
                              (clock-out . "")))

;; Remove the backslash continuation marker
(setq org-log-into-drawer t)
(setq org-log-states-order-reversed t)

;; Use visual line mode for better multi-line notes
(add-hook 'org-mode-hook 'visual-line-mode)

(defun my/get-org-entry-logbook-notes ()
  "Extract LOGBOOK notes from the current entry, handling various org-mode log formats."
  (let ((notes nil))
    (org-with-wide-buffer
     (org-back-to-heading t)
     (let ((end (save-excursion (outline-next-heading) (point)))
           (case-fold-search t))
       ;; Find the LOGBOOK drawer
       (when (re-search-forward "^[ \t]*:LOGBOOK:[ \t]*$" end t)
         (let ((drawer-start (point))
               (drawer-end (save-excursion
                             (re-search-forward "^[ \t]*:END:[ \t]*$" end t)
                             (point))))
           
           ;; Return to start of drawer
           (goto-char drawer-start)
           
           ;; Process each line in the drawer
           (while (< (point) drawer-end)
             (cond
              ;; Match standard note entries (with timestamp at end)
              ((looking-at "[ \t]*- Note \\(.*\\)\\[\\([^]]+\\)\\]$")
               (let ((content (string-trim (match-string-no-properties 1)))
                     (timestamp (match-string-no-properties 2)))
                 (push (cons timestamp content) notes)
                 (forward-line 1)))
              
              ;; Match old-style note entries (with timestamp at beginning)
              ((looking-at "[ \t]*- Note taken on \\[\\([^]]+\\)\\]\\(.*\\)$")
               (let ((timestamp (match-string-no-properties 1))
                     (content "")
                     (has-continuation (string-match-p "\\\\[ \t]*$" (match-string 2))))
                 
                 ;; Get content from first line (after the timestamp)
                 (setq content (string-trim (replace-regexp-in-string "\\\\[ \t]*$" "" (match-string-no-properties 2))))
                 
                 ;; If there's a continuation marker, get content from following lines
                 (when has-continuation
                   (forward-line 1)
                   (while (and (< (point) drawer-end)
                               (looking-at "[ \t]+\\(.+\\)$"))
                     (setq content 
                           (concat content 
                                   (if (string= content "") "" " ") 
                                   (match-string-no-properties 1)))
                     (forward-line 1)))
                 
                 ;; Store the note if we have content
                 (when (not (string= content ""))
                   (push (cons timestamp content) notes))))
              
              ;; Match state changes
              ((looking-at "[ \t]*- State \"\\([^\"]+\\)\"[ \t]+from \"\\([^\"]+\\)\"[ \t]+\\[\\([^]]+\\)\\]")
               (let ((new-state (match-string-no-properties 1))
                     (old-state (match-string-no-properties 2))
                     (timestamp (match-string-no-properties 3)))
                 (push (cons timestamp (format "Changed from %s to %s" old-state new-state)) notes)
                 (forward-line 1)))
              
              ;; Skip any other lines
              (t (forward-line 1))))))))
    (nreverse notes)))
(defun org-dblock-write:standup-report (params)
  "Write out a standup report dynamic block using built-in org functions."
  (let* ((date (or (plist-get params :date) (format-time-string "%Y-%m-%d")))
         (files (or (plist-get params :files) '("~/org/tasks.org")))
         (entries nil))
    
    ;; For each file
    (dolist (file files)
      (with-current-buffer (find-file-noselect file)
        (org-map-entries
         (lambda ()
           (let* ((heading (org-get-heading t t t t))
                  (assigned (org-entry-get nil "ASSIGNED"))
                  (todo-state (org-get-todo-state))
                  ;; Create a file link with line number instead of ID link
                  (file-path (buffer-file-name))
                  (link (format "[[file:%s::%s][%s]]" 
                                file-path
                                heading
                                heading))
                  (logbook (my/get-org-entry-logbook-notes))
                  (date-logs (seq-filter
                              (lambda (log)
                                (string-match-p date (car log)))
                              logbook)))
             (when date-logs
               (push (list link assigned todo-state date-logs) entries))))
         nil nil)))
    
    ;; Insert the collected data
    (if entries
        (progn
          (insert "** Updates for " date "\n")
          (dolist (entry (nreverse entries))
            (let ((link (nth 0 entry))
                  (assigned (nth 1 entry))
                  (todo-state (nth 2 entry))
                  (logs (nth 3 entry)))
              (insert "*** " link)
              (when todo-state
                (insert " [" todo-state "]"))
              (when assigned
                (insert " (" assigned ")"))
              (insert "\n")
              (dolist (log logs)
                (insert "    - " (car log) ": " (cdr log) "\n")))))
      (insert "** No updates found for " date "\n"))))

(with-eval-after-load 'org
  (org-dynamic-block-define "standup-report" 'standup-report))

(defun my/create-todays-standup ()
  "Create today's standup entry with an automatic report of all LOGBOOK entries."
  (interactive)
  (let* ((today (format-time-string "%Y-%m-%d"))
         (today-heading (format-time-string "* Standup %Y-%m-%d %A"))
         (standup-file "~/org/standups.org"))
    
    ;; Open standups.org file
    (find-file standup-file)
    
    ;; Check if today's entry already exists
    (goto-char (point-min))
    (unless (re-search-forward (format "^%s" (regexp-quote today-heading)) nil t)
      ;; Create new heading for today
      (goto-char (point-max))
      (unless (bolp) (insert "\n"))
      (insert today-heading "\n\n")
      
      ;; Insert dynamic block
      (insert "#+BEGIN: standup-report :date \"" today "\"\n")
      (insert "#+END:\n\n")
      (insert "** Action Items\n\n")
      
      ;; Position cursor at the dynamic block
      (search-backward "#+BEGIN:")
      
      ;; Execute the dynamic block
      (org-ctrl-c-ctrl-c)
      
      ;; Move to Action Items for additional notes
      (search-forward "** Action Items")
      (forward-line 1)
      
      (message "Created standup entry for %s" today))
    
    ;; If entry already exists, just go to it
    (goto-char (point-min))
    (when (re-search-forward (format "^%s" (regexp-quote today-heading)) nil t)
      (org-show-entry)
      (message "Opened existing standup for %s" today))))
(defun my/get-org-entry-logbook-notes ()
  "Extract LOGBOOK notes from the current entry, handling various org-mode log formats."
  (let ((notes nil))
    (org-with-wide-buffer
     (org-back-to-heading t)
     (let ((end (save-excursion (outline-next-heading) (point)))
           (case-fold-search t))
       ;; Find the LOGBOOK drawer
       (when (re-search-forward "^[ \t]*:LOGBOOK:[ \t]*$" end t)
         (let ((drawer-start (point))
               (drawer-end (save-excursion
                             (re-search-forward "^[ \t]*:END:[ \t]*$" end t)
                             (point))))
           
           ;; Return to start of drawer
           (goto-char drawer-start)
           
           ;; Process each line in the drawer
           (while (< (point) drawer-end)
             (cond
              ;; Match standard note entries (with timestamp at end)
              ((looking-at "[ \t]*- Note \\(.*\\)\\[\\([^]]+\\)\\]$")
               (let ((content (string-trim (match-string-no-properties 1)))
                     (timestamp (match-string-no-properties 2)))
                 (push (cons timestamp content) notes)
                 (forward-line 1)))
              
              ;; Match old-style note entries (with timestamp at beginning)
              ((looking-at "[ \t]*- Note taken on \\[\\([^]]+\\)\\]\\(.*\\)?$")
               (let ((timestamp (match-string-no-properties 1))
                     (content (or (match-string-no-properties 2) ""))
                     (has-continuation (and (match-string 2) 
                                            (string-match-p "\\\\[ \t]*$" (match-string 2)))))
                 
                 ;; Get content from first line (after the timestamp)
                 (setq content (string-trim (replace-regexp-in-string "\\\\[ \t]*$" "" content)))
                 
                 ;; If there's a continuation marker, get content from following lines
                 (when has-continuation
                   (forward-line 1)
                   (while (and (< (point) drawer-end)
                               (looking-at "[ \t]+\\(.+\\)$"))
                     (setq content 
                           (concat content 
                                   (if (string= content "") "" " ") 
                                   (match-string-no-properties 1)))
                     (forward-line 1)))
                 
                 ;; Store the note even if content is empty
                 (push (cons timestamp content) notes)
                 (unless has-continuation
                   (forward-line 1))))
              
              ;; Match state changes
              ((looking-at "[ \t]*- State \"\\([^\"]+\\)\"[ \t]+from \"\\([^\"]+\\)\"[ \t]+\\[\\([^]]+\\)\\]")
               (let ((new-state (match-string-no-properties 1))
                     (old-state (match-string-no-properties 2))
                     (timestamp (match-string-no-properties 3)))
                 (push (cons timestamp (format "Changed from %s to %s" old-state new-state)) notes)
                 (forward-line 1)))
              
              ;; Skip any other lines
              (t (forward-line 1))))))))
    (nreverse notes)))

;; Bind to convenient keys
(global-set-key (kbd "C-c s s") 'my/create-todays-standup)
(global-set-key (kbd "C-c s r") 'my/refresh-standup-report)
#+end_src
* Buffer customizations (prot tips to ensure they open in specific windows)
Need to borrow some useful configuration to control mini buffer from Prot's youtube video.  I have deferred this for a while.  Once i live with my configuration for a while i will be in a better position to understand what exactly i am missing.  Better not start with what someone feels is a good way to configure buffers. 

* =project.el= configuration

#+begin_src emacs-lisp

  ;; Project configuration
  (use-package project
    :ensure nil  ; built into Emacs
    :config
    ;; Custom project root finding function
    (defun my/project-try-deps-edn (dir)
      "Return project instance if DIR has deps.edn file."
      (let ((proj-file (locate-dominating-file dir "deps.edn")))
        (if proj-file
            (cons 'deps-edn proj-file)
          nil)))
    
    (defun my/project-try-project-clj (dir)
      "Return project instance if DIR has project.clj file."
      (let ((proj-file (locate-dominating-file dir "project.clj")))
        (if proj-file
            (cons 'lein proj-file)
          nil)))
    
    ;; Define how to get root for deps.edn projects
    (cl-defmethod project-root ((project (head deps-edn)))
      (cdr project))
    
    ;; Add Clojure project detection
    (add-hook 'project-find-functions #'my/project-try-deps-edn)
    (add-hook 'project-find-functions #'my/project-try-project-clj))

  (setq project-vc-extra-root-markers '("pyproject.toml" "setup.py" ".git" "requirements.txt"))

  ;; Convenient keybindings for project.el
  (global-set-key (kbd "C-c p f") #'project-find-file)
  (global-set-key (kbd "C-c p d") #'project-find-dir)
  (global-set-key (kbd "C-c p b") #'project-switch-to-buffer)
  (global-set-key (kbd "C-c p p") #'project-switch-project)
  (global-set-key (kbd "C-c p s") #'project-shell)
  (global-set-key (kbd "C-c p g") #'project-find-regexp)
  (global-set-key (kbd "C-c p e") #'project-eshell)

  (setq project-additional-project-dirs 
        '("~/automation_scripts" "pyprojects"))

  (with-eval-after-load 'evil
    (evil-define-key '(normal visual) prog-mode-map
      (kbd "C-.") 'embark-act))
#+end_src

#+RESULTS:

* =vertico= configuration

#+begin_src emacs-lisp
(message "Loading: Completion System - Vertico")
  ;; Enable vertico
  (use-package vertico
    :ensure nil
    :custom
    ;; (vertico-scroll-margin 0) ;; Different scroll margin
    ;; (vertico-count 20) ;; Show more candidates
    (vertico-resize t) ;; Grow and shrink the Vertico minibuffer
    (vertico-cycle t) ;; Enable cycling for `vertico-next/previous'
    :init
    (vertico-mode))

  ;; Persist history over Emacs restarts. Vertico sorts by history position.
  (use-package savehist
    :ensure nil
    :init
    (savehist-mode))  
#+end_src

* =marginalia= configuration

#+begin_src emacs-lisp

  ;; Enable rich annotations using the Marginalia package
  (use-package marginalia
    :ensure nil
    ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
    ;; available in the *Completions* buffer, add it to the
    ;; `completion-list-mode-map'.
    :bind (:map minibuffer-local-map
                ("M-A" . marginalia-cycle))

    ;; The :init section is always executed.
    :init

    ;; Marginalia must be activated in the :init section of use-package such that
    ;; the mode gets enabled right away. Note that this forces loading the
    ;; package.
    (marginalia-mode))
#+end_src

* =consult= configuration

#+begin_src emacs-lisp
(message "Loading: Completion System - Consult")

  ;; Example configuration for Consult
  (use-package consult
    :ensure nil
    ;; Replace bindings. Lazily loaded by `use-package'.
    :bind (;; C-c bindings in `mode-specific-map'
           ("C-c M-x" . consult-mode-command)
           ("C-c h" . consult-history)
           ("C-c k" . consult-kmacro)
           ("C-c m" . consult-man)
           ("C-c i" . consult-info)
           ([remap Info-search] . consult-info)
           ;; C-x bindings in `ctl-x-map'
           ("C-x M-:" . consult-complex-command)     ;; orig. repeat-complex-command
           ("C-x b" . consult-buffer)                ;; orig. switch-to-buffer
           ("C-x 4 b" . consult-buffer-other-window) ;; orig. switch-to-buffer-other-window
           ("C-x 5 b" . consult-buffer-other-frame)  ;; orig. switch-to-buffer-other-frame
           ("C-x t b" . consult-buffer-other-tab)    ;; orig. switch-to-buffer-other-tab
           ("C-x r b" . consult-bookmark)            ;; orig. bookmark-jump
           ("C-x p b" . consult-project-buffer)      ;; orig. project-switch-to-buffer
           ;; Custom M-# bindings for fast register access
           ("M-#" . consult-register-load)
           ("M-'" . consult-register-store)          ;; orig. abbrev-prefix-mark (unrelated)
           ("C-M-#" . consult-register)
           ;; Other custom bindings
           ("M-y" . consult-yank-pop)                ;; orig. yank-pop
           ;; M-g bindings in `goto-map'
           ("M-g e" . consult-compile-error)
           ("M-g f" . consult-flymake)               ;; Alternative: consult-flycheck
           ("M-g g" . consult-goto-line)             ;; orig. goto-line
           ("M-g M-g" . consult-goto-line)           ;; orig. goto-line
           ("M-g o" . consult-outline)               ;; Alternative: consult-org-heading
           ("M-g m" . consult-mark)
           ("M-g k" . consult-global-mark)
           ("M-g i" . consult-imenu)
           ("M-g I" . consult-imenu-multi)
           ;; M-s bindings in `search-map'
           ("M-s d" . consult-find)                  ;; Alternative: consult-fd
           ("M-s c" . consult-locate)
           ("M-s g" . consult-grep)
           ("M-s G" . consult-git-grep)
           ("M-s r" . consult-ripgrep)
           ("M-s l" . consult-line)
           ("M-s L" . consult-line-multi)
           ("M-s k" . consult-keep-lines)
           ("M-s u" . consult-focus-lines)
           ;; Isearch integration
           ("M-s e" . consult-isearch-history)
           :map isearch-mode-map
           ("M-e" . consult-isearch-history)         ;; orig. isearch-edit-string
           ("M-s e" . consult-isearch-history)       ;; orig. isearch-edit-string
           ("M-s l" . consult-line)                  ;; needed by consult-line to detect isearch
           ("M-s L" . consult-line-multi)            ;; needed by consult-line to detect isearch
           ;; Minibuffer history
           :map minibuffer-local-map
           ("M-s" . consult-history)                 ;; orig. next-matching-history-element
           ("M-r" . consult-history))                ;; orig. previous-matching-history-element

    ;; Enable automatic preview at point in the *Completions* buffer. This is
    ;; relevant when you use the default completion UI.
    :hook (completion-list-mode . consult-preview-at-point-mode)

    ;; The :init configuration is always executed (Not lazy)
    :init

    ;; Optionally configure the register formatting. This improves the register
    ;; preview for `consult-register', `consult-register-load',
    ;; `consult-register-store' and the Emacs built-ins.
    (setq register-preview-delay 0.5
          register-preview-function #'consult-register-format)

    ;; Optionally tweak the register preview window.
    ;; This adds thin lines, sorting and hides the mode line of the window.
    (advice-add #'register-preview :override #'consult-register-window)

    ;; Use Consult to select xref locations with preview
    (setq xref-show-xrefs-function #'consult-xref
          xref-show-definitions-function #'consult-xref)

    ;; Configure other variables and modes in the :config section,
    ;; after lazily loading the package.
    :config

    ;; Optionally configure preview. The default value
    ;; is 'any, such that any key triggers the preview.
    ;; (setq consult-preview-key 'any)
    ;; (setq consult-preview-key "M-.")
    ;; (setq consult-preview-key '("S-<down>" "S-<up>"))
    ;; For some commands and buffer sources it is useful to configure the
    ;; :preview-key on a per-command basis using the `consult-customize' macro.
    (consult-customize
     consult-theme :preview-key '(:debounce 0.2 any)
     consult-ripgrep consult-git-grep consult-grep
     consult-bookmark consult-recent-file consult-xref
     consult--source-bookmark consult--source-file-register
     consult--source-recent-file consult--source-project-recent-file
     ;; :preview-key "M-."
     :preview-key '(:debounce 0.4 any))

    ;; Optionally configure the narrowing key.
    ;; Both < and C-+ work reasonably well.
    (setq consult-narrow-key "<") ;; "C-+"

    ;; Optionally make narrowing help available in the minibuffer.
    ;; You may want to use `embark-prefix-help-command' or which-key instead.
    ;; (keymap-set consult-narrow-map (concat consult-narrow-key " ?") #'consult-narrow-help)
    )

  (use-package consult-lsp
    :ensure nil
    
    )

  (use-package consult-project-extra
    :ensure nil
    :bind
    (("C-c p f" . consult-project-extra-find)
     ("C-c p o" . consult-project-extra-find-other-window)))

#+end_src
    
* Consult - Custom extensions

#+begin_src emacs-lisp

  (defun my/consult-find-across-projects ()
    "Find files across all known projects."
    (interactive)
    (let* ((projects (project-known-project-roots))
           (dirs (cl-remove-if-not #'file-exists-p projects)))
      (consult-find dirs)))

  ;; Bind it to a key
  (global-set-key (kbd "C-c p F") #'my/consult-find-across-projects)
  (global-set-key (kbd "M-s F") #'my/consult-find-across-projects)

#+end_src

* =dgrep= for search and replace across files (not buffers)
this will allow us to make changes across multiple unopened files in file system within a project using a combination of consult-ripgrep, embark-act and wgrep-change-to-wgrep-mode

#+begin_src emacs-lisp

(use-package wgrep
  :ensure nil
  :config
  ;; Allow editing in `grep` buffers
  (setq wgrep-auto-save-buffer t) ; Automatically save changes when finishing edits
  (setq wgrep-change-readonly-file t) ; Allow editing read-only files

  ;; Keybindings for `wgrep` mode
  (define-key wgrep-mode-map (kbd "C-c C-c") 'wgrep-finish-edit) ; Save changes
  (define-key wgrep-mode-map (kbd "C-c C-k") 'wgrep-abort-changes)) ; Abort changes

(defun my/embark-collect-wgrep-mode ()
  "Enable `wgrep` mode in the current `embark-collect` buffer."
  (interactive)
  (message "Enabling wgrep-mode...")
  (wgrep-change-to-wgrep-mode)) ; Enable `wgrep` mode

(with-eval-after-load 'embark
  ;; Bind `e` to enable `wgrep` mode in `embark-collect` buffers
  (evil-define-key 'normal embark-collect-mode-map (kbd "e") 'my/embark-collect-wgrep-mode))

(with-eval-after-load 'evil
  ;; Ensure `C-c C-c` works in `wgrep-mode` with `evil-mode`
  (evil-define-key 'normal wgrep-mode-map (kbd "C-c C-c") 'wgrep-finish-edit))

#+end_src

* =embark= configuration

#+begin_src emacs-lisp
(use-package embark
  :ensure nil
  :bind
  (("C-." . embark-act)         ;; pick some comfortable binding
   ("C->" . embark-become)      ;; pick some comfortable binding
   ("C-;" . embark-dwim)        ;; good alternative: M-.
   ("C-h B" . embark-bindings)) ;; alternative for `describe-bindings'

  :init

  ;; Optionally replace the key help with a completing-read interface
  (setq prefix-help-command #'embark-prefix-help-command)

  ;; Show the Embark target at point via Eldoc. You may adjust the
  ;; Eldoc strategy, if you want to see the documentation from
  ;; multiple providers. Beware that using this can be a little
  ;; jarring since the message shown in the minibuffer can be more
  ;; than one line, causing the modeline to move up and down:

  ;; (add-hook 'eldoc-documentation-functions #'embark-eldoc-first-target)
  ;; (setq eldoc-documentation-strategy #'eldoc-documentation-compose-eagerly)

  :config

  ;; Hide the mode line of the Embark live/completions buffers
  (add-to-list 'display-buffer-alist
               '("\\`\\*Embark Collect \\(Live\\|Completions\\)\\*"
                 nil
                 (window-parameters (mode-line-format . none)))))
;; Consult users will also want the embark-consult package.
(use-package embark-consult
  :ensure nil ; only need to install it, embark loads it after consult if found
  :hook
  (embark-collect-mode . consult-preview-at-point-mode))

#+end_src

* =orderless= configuration

#+begin_src emacs-lisp

  (use-package orderless
    :ensure nil
    :custom
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles basic partial-completion)))))  
#+end_src

* =cape= Configuration

#+begin_src emacs-lisp

;; diabling company as we have corfu and cape for completions.
;; (global-company-mode -1)

;; Completion Setup with Cape and Corfu
(use-package cape
  :ensure nil
  :init
  ;; Add useful defaults completion sources from Cape
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  :hook (python-ts-mode . (lambda ()
                            (add-to-list 'completion-at-point-functions #'cape-file)
                            (add-to-list 'completion-at-point-functions #'cape-dabbrev)))
  :config
  ;; Define a list of completion sources
  (setq cape-completion-sources
        '(cape-file
          cape-dabbrev
          cape-history
          cape-keyword
          cape-tex
          cape-abbrev))
  
  ;; Add all sources to completion-at-point-functions
  (dolist (source cape-completion-sources)
    (add-to-list 'completion-at-point-functions source)))

#+end_src

* Python test configuration

#+begin_src emacs-lisp 

(use-package pytest
  :ensure nil
  :after python
  :commands (pytest-one
    	     pytest-pdb-one
    	     pytest-all
    	     pytest-module
    	     pytest-last-failed)
  :config
  (setq pytest-cmd-flags "--cov=app --cov-report=term --cov-report=html")
  :bind (:map python-mode-map
              ("C-c t f" . pytest-file)
              ("C-c t t" . pytest-function)
              ("C-c t a" . pytest-all)
              ("C-c t m" . pytest-module)
              ("C-c t r" . pytest-repeat)))

(use-package coverage
  :ensure nil
  :config
  (setq coverage-path ".coverage")
  :bind (:map python-mode-map
              ("C-c c" . coverage-mode)))

(use-package flycheck
  :ensure nil
  :init (global-flycheck-mode)
  :config
  (setq flycheck-python-pylint-executable "pylint")
  (setq flycheck-python-flake8-executable "flake8")
  ;; Disable problematic nix checker due to GLIBCXX version conflicts
  (setq flycheck-disabled-checkers '(nix)))

;; More detailed coverage setup
(defun setup-python-coverage ()
  "Set up coverage visualization for Python projects."
  (interactive)
  (let ((coverage-html-dir (concat (projectile-project-root) "htmlcov")))
    (if (file-exists-p coverage-html-dir)
        (browse-url (concat "file://" coverage-html-dir "/index.html"))
      (message "No coverage report found. Run tests with coverage first."))))

(defun run-pytest-with-coverage ()
  "Run pytest with coverage on the current project."
  (interactive)
  (let ((default-directory (projectile-project-root)))
    (compile "python -m pytest --cov=. --cov-report=html")))

(global-set-key (kbd "C-c C-t") 'run-pytest-with-coverage)
(global-set-key (kbd "C-c C-v") 'setup-python-coverage)


#+end_src

* Python BDD Specific configuration

#+begin_src emacs-lisp 

(use-package feature-mode
  :ensure nil)
(add-to-list 'auto-mode-alist '("\.feature$" . feature-mode))


#+end_src

* =corfu= Configuration

#+begin_src emacs-lisp

  (use-package corfu
    :ensure nil
    :custom
    (corfu-auto t)  ; Enable auto completion
    (corfu-auto-delay 0.2)
    (corfu-auto-prefix 2)
    (corfu-preview-current nil)
    (corfu-quit-at-boundary 'separator)

    :init
    (global-corfu-mode)

    :hook
    ((clojure-mode . corfu-mode)
     (cider-repl-mode . corfu-mode)
     (python-ts-mode . corfu-mode)))

  ;; Optional: Enable Corfu in the minibuffer
  (defun corfu-enable-in-minibuffer ()
    "Enable Corfu in the minibuffer if `completion-at-point' is bound."
    (when (where-is-internal #'completion-at-points (list (current-local-map)))
      (corfu-mode 1)))

  (add-hook 'minibuffer-setup-hook #'corfu-enable-in-minibuffer)
#+end_src

* =magit= to start working with Git.

* Clojure support

#+begin_src emacs-lisp

(use-package clojure-mode
  :ensure nil
  :custom
  (clojure-align-forms-automatically t))

(use-package cider
  :ensure nil
  :custom
  (cider-repl-pop-to-buffer-on-connect nil)
  (cider-save-file-on-load t)
  (cider-save-file-on-load t)
  :config

  (setq cider-repl-display-help-banner nil)
  (setq cider-print-fn 'puget)
  (setq cider-repl-use-pretty-printing t)
  (setq cider-clojure-cli-aliases ":dev:cider"))

(use-package rainbow-delimiters
  :ensure nil
  :hook ((clojure-mode . rainbow-delimiters-mode)
         (cider-repl-mode . rainbow-delimiters-mode)))

;; In your Clojure configuration section, add these key bindings:
(with-eval-after-load 'clojure-mode
  (define-key clojure-mode-map [f3] 'cider-find-var)  ; equivalent to lsp-find-definition
  (define-key clojure-mode-map [f4] 'cider-xref-fn-refs-select) ; equivalent to lsp-find-references
  (define-key clojure-mode-map (kbd "M-.") 'cider-find-var)
  (define-key clojure-mode-map (kbd "M-,") 'cider-pop-back))

;; Also add Evil bindings if needed
(with-eval-after-load 'evil
  (evil-define-key '(normal visual) clojure-mode-map
    (kbd "C-.") 'embark-act
    (kbd "M-.") 'cider-find-var
    (kbd "M-,") 'cider-pop-back))

#+end_src

* Cider REPL Configuration

#+begin_src emacs-lisp

  ;; Debugging Setup
  (setq cider-cljs-lein-repl
        "(do (require 'figwheel-sidecar.repl-api)
           (figwheel-sidecar.repl-api/start-figwheel!)
           (figwheel-sidecar.repl-api/cljs-repl))")

  (setq cider-debug-display-locals t)
  (setq cider-debug-prompt 'overlay)

  ;; Optional but Recommended Packages
  (use-package clj-refactor
    :ensure nil
    :config
    (cljr-add-keybindings-with-prefix "C-c C-m")
    :hook (clojure-mode . clj-refactor-mode))

  (use-package flycheck-clj-kondo
    :ensure nil)

  (use-package aggressive-indent
    :ensure nil
    :hook (clojure-mode . aggressive-indent-mode))

  ;; Testing Setup  
  (setq cider-test-show-report-on-success t)
  (setq cider-auto-select-test-report-buffer t)


  ;; REPL Configuration
  (setq cider-repl-history-file ".cider-repl-history")
  (setq cider-repl-wrap-history t)
  (setq cider-repl-history-size 3000)
#+end_src

* =treemacs= configuration
#+begin_src emacs-lisp

(defun my/treemacs-peek ()
  "Peek at file content in a temporary window without creating a permanent buffer."
  (interactive)
  (when-let* ((window (selected-window))
              (btn (treemacs-current-button))
              (file (treemacs-button-get btn :path)))
    (when (file-exists-p file)
      (if-let ((peek-window (next-window)))
          (with-selected-window peek-window
            (find-file file)
            (read-only-mode -1))  ; Make buffer writable
        (split-window-right)
        (other-window 1)
        (find-file file)
        (read-only-mode -1))  ; Make buffer writable
      (message "Peek mode: press q to close"))))

(defun my/treemacs-close-peek ()
  "Close the peek window if it exists."
  (interactive)
  (when (and (eq major-mode 'treemacs-mode)
             (> (count-windows) 1))
    (delete-window (next-window))))

(use-package treemacs
  :ensure nil
  :config
  (setq treemacs-indentation 1
  	treemacs-indentation-string "  "
  	treemacs-width 35
  	treemacs-show-hidden-files t
  	treemacs-show-git-status t
  	treemacs-no-png-images nil
  	treemacs-collapse-dirs 3
  	treemacs-follow-mode t
  	treemacs-project-follow-mode t)

  (treemacs-load-theme "all-the-icons")

  :bind
  (:map global-map
	("C-c t t" . treemacs)
	("C-c t f" . treemacs-select-window)))

(add-hook 'treemacs-mode-hook
      	    (lambda() (display-line-numbers-mode -1)))

(with-eval-after-load 'treemacs
  (define-key treemacs-mode-map (kbd "P") #'my/treemacs-peek)
  (define-key treemacs-mode-map (kbd "q") #'my/treemacs-close-peek))

#+end_src

* debugging with dap-mode?

Starting to believe i will never use DAP

#+begin_src emacs-lisp

  ;; will implement later.
  
#+end_src

* Some packages that make it easy to work with JSON-MEM

#+begin_src emacs-lisp

;; JSON navigation with TAB behavior similar to org-mode
(defun my/json-next-element ()
  "Move to next element in a JSON array, handling nested structures."
  (interactive)
  (let ((depth 0)
	(in-string nil))
    ;; Keep moving forward until we find a comma at our nesting level
    (while (and (< (point) (point-max))  ; don't go past end of buffer
		(or (/= depth 0)          ; keep going if we're in nested structure
                    (not (looking-at-p ","))))  ; or haven't found a comma
      ;; Track if we're in a string
      (when (and (looking-at-p "\"")
                 (not (save-excursion (backward-char) (looking-at-p "\\\\"))))
	(setq in-string (not in-string)))
      
      ;; Only count brackets when not in string
      (when (not in-string)
	(cond ((looking-at-p "[[{]")
               (setq depth (1+ depth)))
              ((looking-at-p "[]}]")
               (setq depth (1- depth)))))
      
      (forward-char))
    
    ;; If we found a comma, move past it and any whitespace
    (when (looking-at-p ",")
      (forward-char)
      (skip-chars-forward "[:space:]\n")))) 

(defun my/json-previous-element ()
  "Move to previous element in a JSON array, handling nested structures."
  (interactive)
  (let ((depth 0)
	(in-string nil))
    ;; Keep moving backward until we find a comma at our nesting level
    (while (and (> (point) (point-min))  ; don't go past start of buffer
		(or (/= depth 0)          ; keep going if we're in nested structure
                    (not (looking-back "," 1))))  ; or haven't found a comma
      (backward-char)
      
      ;; Track if we're in a string
      (when (and (looking-at-p "\"")
		 (not (save-excursion (backward-char) (looking-at-p "\\\\"))))
	(setq in-string (not in-string)))
      
      ;; Only count brackets when not in string
      (when (not in-string)
	(cond ((looking-at-p "[]}]")
               (setq depth (1+ depth)))
              ((looking-at-p "[[{]")
               (setq depth (1- depth))))))
    
    ;; If we found a comma, skip backward over whitespace
    (when (looking-back "," 1)
      (backward-char)
      (skip-chars-backward "[:space:]\n"))))

(use-package json-mode
  :ensure nil
  :config)

(with-eval-after-load 'json-mode
  (with-eval-after-load 'evil
    ;; Use a local hook to set up JSON-specific key handling
    (defun my/setup-json-mode-keys ()
      ;; Locally unbind the keys
      (when (boundp 'evil-normal-state-local-map)
        (define-key evil-normal-state-local-map (kbd "C-n") nil)
        (define-key evil-normal-state-local-map (kbd "C-p") nil))
      
      ;; Add our JSON-specific bindings
      (evil-local-set-key 'normal (kbd "C-n") 'my/json-next-element)
      (evil-local-set-key 'normal (kbd "C-p") 'my/json-previous-element))
    
    ;; Add the hook
    (add-hook 'json-mode-hook 'my/setup-json-mode-keys)))

(use-package yafolding
  :ensure nil)

(use-package yasnippet-capf
  :ensure nil
  :after cape
  :init
  (defun my/yasnippet-capf-h ()
    (add-to-list 'completion-at-point-functions #'yasnippet-capf))
  :hook
  (emacs-lisp-mode . my/yasnippet-capf-h))

#+end_src

* YASnippet Configuration

#+begin_src emacs-lisp
  ;; Basic YASnippet setup
  (use-package yasnippet
    :ensure nil
    :hook ((prog-mode . yas-minor-mode)
           (org-mode . yas-minor-mode)
           (text-mode . yas-minor-mode)
           (cider-repl-mode . yas-minor-mode)        ;; Enable in Clojure REPL
           (inferior-python-mode . yas-minor-mode))  ;; Enable in Python REPL
    :config
    (yas-reload-all)
    (setq yas-snippet-dirs
          '("~/.emacs.d/snippets"  ;; personal snippets
            yasnippet-snippets-dir ;; collection from yasnippet-snippets package
            ))
    :bind
    (:map yas-minor-mode-map
          ("C-c y n" . yas-new-snippet)
          ("C-c y v" . yas-visit-snippet-file)
          ("C-c y i" . yas-insert-snippet)))

  ;; Install the main snippet collection
  (use-package yasnippet-snippets
    :ensure nil
    :after yasnippet)

  ;; Optional: Add Clojure snippets if you work with Clojure
  (use-package clojure-snippets
    :ensure nil
    :after (yasnippet clojure-mode))


  ;; Integrate with Corfu completion
  (with-eval-after-load 'corfu
    (add-to-list 'completion-at-point-functions #'yasnippet-capf))

  ;; Add Consult integration for better snippet selection
  (use-package consult-yasnippet
    :ensure nil
    :bind ("C-c y" . consult-yasnippet))

  (use-package yafolding
    :ensure nil
    :hook ((json-mode . yafolding-mode)
           (json-ts-mode . yafolding-mode)
           (python-ts-mode . yafolding-mode)
           (clojure-mode . yafolding-mode)
           (yaml-mode . yafolding-mode)
           (yaml-ts-mode . yafolding-mode)
           (js-ts-mode . yafolding-mode)
           (typescript-ts-mode . yafolding-mode)
           (css-ts-mode . yafolding-mode)
           (dockerfile-ts-mode . yafolding-mode)
           (toml-ts-mode . yafolding-mode))
    :config
    ;; Global yafolding bindings
    (with-eval-after-load 'yafolding
      (define-key yafolding-mode-map (kbd "C-c C-a") 'yafolding-toggle-all)
      (define-key yafolding-mode-map (kbd "C-c C-s") 'yafolding-show-all)
      (define-key yafolding-mode-map (kbd "C-c C-h") 'yafolding-hide-all)
      (define-key yafolding-mode-map (kbd "C-c [") 'yafolding-hide-region)
      (define-key yafolding-mode-map (kbd "C-c ]") 'yafolding-show-region)

      (evil-define-key 'normal yafolding-mode-map
        (kbd "TAB") 'yafolding-toggle-element))
    
    ;; JSON-specific evil bindings with higher precedence
    (with-eval-after-load 'json-mode
      ;; Remove TAB from global map in json-mode
      (define-key json-mode-map (kbd "TAB") nil)
      ;; Define evil normal state binding
      (evil-define-key 'normal json-mode-map
        [tab] 'yafolding-toggle-element
        (kbd "TAB") 'yafolding-toggle-element)))  

  ;; Origami for universal folding support
  (use-package origami
    :ensure nil
    :hook (prog-mode . origami-mode)
    :config
    ;; Enable for specific modes that work well with origami
    (add-hook 'yaml-mode-hook 'origami-mode)
    (add-hook 'yaml-ts-mode-hook 'origami-mode)
    (add-hook 'js-ts-mode-hook 'origami-mode)
    (add-hook 'typescript-ts-mode-hook 'origami-mode)
    (add-hook 'css-ts-mode-hook 'origami-mode)
    (add-hook 'json-ts-mode-hook 'origami-mode)
    (add-hook 'dockerfile-ts-mode-hook 'origami-mode)
    (add-hook 'toml-ts-mode-hook 'origami-mode)
    (add-hook 'nix-mode-hook 'origami-mode)
    (add-hook 'terraform-mode-hook 'origami-mode)
    
    ;; Key bindings for origami
    (define-key origami-mode-map (kbd "C-c f o") 'origami-open-node)
    (define-key origami-mode-map (kbd "C-c f c") 'origami-close-node)
    (define-key origami-mode-map (kbd "C-c f t") 'origami-toggle-node)
    (define-key origami-mode-map (kbd "C-c f r") 'origami-open-all-nodes)
    (define-key origami-mode-map (kbd "C-c f m") 'origami-close-all-nodes)
    (define-key origami-mode-map (kbd "C-c f s") 'origami-show-only-node)
    
    ;; Evil mode bindings for origami
    (with-eval-after-load 'evil
      (evil-define-key 'normal origami-mode-map
        (kbd "zo") 'origami-open-node
        (kbd "zc") 'origami-close-node
        (kbd "za") 'origami-toggle-node
        (kbd "zR") 'origami-open-all-nodes
        (kbd "zM") 'origami-close-all-nodes)))

#+end_src

* JavaScript/TypeScript Development

#+begin_src emacs-lisp

;; Core JavaScript support
(use-package js2-mode 
  :ensure nil
  :mode "\\.js\\'"
  :config
  (setq js2-basic-offset 2
        js2-bounce-indent-p nil))

;; TypeScript support
(use-package typescript-mode 
  :ensure nil
  :mode ("\\.ts\\'" "\\.tsx\\'")
  :config
  (setq typescript-indent-level 2))

;; React JSX support
(use-package rjsx-mode 
  :ensure nil
  :mode "\\.jsx\\'"
  :config
  (setq js2-basic-offset 2))

;; Web mode for mixed HTML/CSS/JS
(use-package web-mode 
  :ensure nil
  :mode ("\\.html\\'" "\\.vue\\'" "\\.svelte\\'" "\\.tsx\\'")
  :config
  (setq web-mode-markup-indent-offset 2
        web-mode-css-indent-offset 2
        web-mode-code-indent-offset 2
        web-mode-attr-indent-offset 2))

;; Prettier for code formatting
(use-package prettier-js 
  :ensure nil
  :hook ((js2-mode typescript-mode rjsx-mode web-mode) . prettier-js-mode)
  :config
  (setq prettier-js-args '("--single-quote" "--no-semi")))

;; Add node_modules to PATH for project-local tools
(use-package add-node-modules-path 
  :ensure nil
  :hook ((js2-mode typescript-mode rjsx-mode web-mode) . add-node-modules-path))

;; Add Eglot support for JavaScript/TypeScript
(with-eval-after-load 'eglot
  (add-hook 'typescript-mode-hook #'eglot-ensure)
  (add-hook 'js2-mode-hook #'eglot-ensure)
  (add-hook 'rjsx-mode-hook #'eglot-ensure)
  ;; Configure TypeScript language server
  (add-to-list 'eglot-server-programs 
               '((typescript-mode js2-mode rjsx-mode) . ("typescript-language-server" "--stdio"))))

#+end_src

* Configuration File Modes

#+begin_src emacs-lisp

;; YAML support
(use-package yaml-mode 
  :ensure nil
  :mode "\\.ya?ml\\'")

;; TOML support
(use-package toml-mode 
  :ensure nil
  :mode "\\.toml\\'")

;; Dockerfile support
(use-package dockerfile-mode 
  :ensure nil
  :mode "Dockerfile\\'")

;; Terraform support
(use-package terraform-mode 
  :ensure nil
  :mode "\\.tf\\'")

;; Nginx configuration
(use-package nginx-mode 
  :ensure nil
  :mode "/nginx/.*\\.conf\\'")

;; CSV files
(use-package csv-mode 
  :ensure nil
  :mode "\\.csv\\'")

;; Markdown support
(use-package markdown-mode 
  :ensure nil
  :mode ("\\.md\\'" "\\.markdown\\'")
  :config
  (setq markdown-command "multimarkdown"))

;; Systemd files
(use-package systemd 
  :ensure nil
  :mode ("\\.service\\'" "\\.timer\\'" "\\.target\\'" "\\.socket\\'"))

#+end_src

* REST support

#+begin_src emacs-lisp

  (use-package restclient
    :ensure nil
    :mode ("\\.http\\'" . restclient-mode))
  
#+end_src

* Uvicron compilation mappings for FastAPI projects

This is just an easy for me to start up my various python projects.  I realize that this is not generic and is better off outside of dotfiles.  It makes no sense for people who are not involved in these projects

#+begin_src emacs-lisp
;; Create a keymap for uvicorn commands
(defvar uvicorn-command-map
  (let ((map (make-sparse-keymap)))
    (define-key map (kbd "1") 
                (lambda () 
                  (interactive)
                  (let ((default-directory (project-root (project-current t)))
                        (compilation-buffer-name-function
                         (lambda (_mode) "*uvicorn-iOCR*")))
                    (compile "PYTHONPATH=$PYTHONPATH:. uvicorn app.iOCR_app:app --reload --port 8123 --host 0.0.0.0"))))
    
    (define-key map (kbd "2")
                (lambda ()
                  (interactive)
                  (let ((default-directory (project-root (project-current t)))
                        (compilation-buffer-name-function
                         (lambda (_mode) "*uvicorn-CVC*")))
                    (compile "PYTHONPATH=$PYTHONPATH:. uvicorn app.CVC_app:app --reload --port 8124 --host 0.0.0.0"))))

    (define-key map (kbd "3")
                (lambda ()
                  (interactive)
                  (let ((default-directory (project-root (project-current t)))
                        (compilation-buffer-name-function
                         (lambda (_mode) "*uvicorn-Blens*")))
                    (compile "PYTHONPATH=$PYTHONPATH:. uvicorn app.billuminati-app:app --reload --port 8125 --host 0.0.0.0"))))

    (define-key map (kbd "4")
                (lambda ()
                  (interactive)
                  (let ((default-directory (project-root (project-current t)))
                        (compilation-buffer-name-function
                         (lambda (_mode) "*uvicorn-capture*")))
                    (compile "PYTHONPATH=$PYTHONPATH:. uvicorn tests.api_server:app --reload --port 8125 --host 0.0.0.0"))))
    map))

;; Create the prefix key binding
(global-set-key (kbd "C-c u") uvicorn-command-map)

;; Add which-key descriptions
(with-eval-after-load 'which-key
  (which-key-add-key-based-replacements
    "C-c u" "uvicorn"
    "C-c u 1" "start iOCR"
    "C-c u 2" "start CVC"
    "C-c u 3" "start Billi"
    "C-c u 4" "start Billi capture"))  
#+end_src

* Evil - Elisp keymap customization
This doesnt seem to be working as expected.  messing up the code.  Can move this to the paredit area.  I think paredit already has C-M-u/d/n/p which kind of get this done and these bindings are somewhat difficult to remember unless you have already used it a lot in vim and have developed muscle memory
Needs to be placed along with all the other with-eval-after-load 'evil customizations so that they are all in one place

#+begin_src emacs-lisp

(with-eval-after-load 'evil
  (evil-define-key '(normal visual) emacs-lisp-mode-map
    (kbd "C-.") 'embark-act
    (kbd "]e") 'evil-cp-end-of-defun    
    (kbd "[e") 'evil-cp-beginning-of-defun  
    (kbd "M-j") 'evil-cp-next-sexp      
    (kbd "M-k") 'evil-cp-previous-sexp)) 

#+end_src

* Evil - Buffer customization
This overrides evil behaviour of using Esc to close special buffers.  This sometimes causes more harm than good.  this becomes necessary because in buffers like python compilation and repl and eshell, if Vi is active, then you are forced to hit esc to use other commands that allow you do search in the buffer etc.  The solution is to learn to some some emacs native navigation commands to move around in such buffers otherwise, hitting Esc closes the buffers and for someone using Vi, hitting Esc is second nature 

#+begin_src emacs-lisp

  ;; Prevent ESC from closing windows in special buffers
  (with-eval-after-load 'evil
    (evil-define-key 'normal special-mode-map [escape] 'evil-normal-state)
    (evil-define-key 'normal compilation-mode-map [escape] 'evil-normal-state)
    (evil-define-key 'normal cider-repl-mode-map [escape] 'evil-normal-state))

  ;; Alternative approach if the above doesn't work for all cases
  (defun my/prevent-escape-window-close ()
    "Prevent escape from closing windows in special buffers."
    (local-set-key [escape] 'evil-normal-state))

  (add-hook 'compilation-mode-hook #'my/prevent-escape-window-close)
  (add-hook 'special-mode-hook #'my/prevent-escape-window-close)
  (add-hook 'cider-repl-mode-hook #'my/prevent-escape-window-close)

#+end_src

* MANAGED BY EMACS
** TODO Have no clue if this is actually being used at all

#+begin_src emacs-lisp

(custom-set-variables
 ;; custom-set-variables was added by Custom.
 ;; If you edit it by hand, you could mess it up, so be careful.
 ;; Your init file should contain only one such instance.
 ;; If there is more than one, they won't work right.
 '(safe-local-variable-values
   '((eval add-hook 'cider-connected-hook
	   (lambda nil
	     (shell-command "npx shadow-cljs server")
	     (sleep-for 5)
	     (shell-command "npm run watch:css &"))
	   nil 'local)
     (auto-save-default)
     (make-backup-files)
     (eval pyvenv-activate
	   (expand-file-name ".venv"
			     (project-root
			      (project-current)))))))

#+end_src

* Tramp specific setup

#+begin_src emacs-lisp
;; Prevent TRAMP from hanging with Vertico
(setq remote-file-name-inhibit-cache nil)
;; (setq tramp-shell-prompt-pattern "\\(?:^\\|\r\\)[^]#$%>\n]*#?[]#$%>].* *\\(^[\\[[0-9;]*[a-zA-Z] *\\)*")
(setq tramp-verbose 1)

;; Improve TRAMP performance with Vertico/Marginalia
(setq tramp-completion-reread-directory-timeout nil)

;; Disable Corfu on remote files
(add-hook 'corfu-mode-hook
          (lambda ()
            (when (file-remote-p default-directory)
              (corfu-mode -1))))

;; Adjust Project.el for better TRAMP handling
(setq project-switch-commands 'project-find-file)

;; Optional: Disable Cape file completion on remote files
(setq cape-file-directory-must-exist nil)
#+end_src

* EWW configuration

** TODO Probably something that i will get rid of later on.  I dont see myself using this at all

#+begin_src emacs-lisp 

;; EWW configuration
(require 'eww)
(setq browse-url-browser-function 'eww-browse-url) ;; Use EWW as default browser
(setq eww-search-prefix "https://duckduckgo.com/html?q=") ;; Set search engine

;; Nicer rendering
(setq shr-use-colors nil) ;; No colors
(setq shr-use-fonts t)    ;; Use fonts
(setq shr-max-width 80)   ;; Wrap at 80 chars
(setq shr-discard-aria-hidden t)

;; Key bindings for EWW
(global-set-key (kbd "C-c w") 'eww)
(global-set-key (kbd "C-c o") 'browse-url-external) ;; Open in external browser when needed

#+end_src

* Nix mode
** TODO There is also a =nix-ts-mode=.  wonder if that is complementary to this.  Need to figure it out

#+begin_src emacs-lisp

(use-package transient
  :ensure nil)

(use-package nix-mode
  :ensure nil)

#+end_src

* mu4e-dashboard

#+begin_src emacs-lisp 

;; Load mu4e-dashboard
(use-package mu4e-dashboard
  :after mu4e
  :config
  ;; Set the dashboard file
  (setq mu4e-dashboard-file "~/.config/emacs/mu4e-dashboard.org")
  
  ;; If you want a default dashboard, you might need to create one
  ;; or copy the example from the repository
  
  ;; Optional: bind a key to open the dashboard
  :bind (:map mu4e-main-mode-map
              ("d" . mu4e-dashboard)))

#+end_src

* Editor customization for programming modes
** move-text

#+begin_src emacs-lisp

(use-package move-text
  :ensure nil
  :bind
  (("C-M-<up>" . move-text-up)
   ("C-M-<down>" . move-text-down)))
#+end_src

** Paredit

#+begin_src emacs-lisp

(use-package paredit
  :ensure nil
  :hook ((emacs-lisp-mode
          clojure-mode
          clojurescript-mode
          cider-repl-mode) . paredit-mode)
  :config
  ;; Bind paredit commands in insert state for elisp
  (evil-define-key 'insert emacs-lisp-mode-map
    (kbd "C-<left>") 'paredit-backward-slurp-sexp
    (kbd "C-<right>") 'paredit-forward-slurp-sexp
    (kbd "C-M-<left>") 'paredit-backward-barf-sexp
    (kbd "C-M-<right>") 'paredit-forward-barf-sexp)
  
  ;; Same bindings for clojure modes
  (evil-define-key 'insert clojure-mode-map
    (kbd "C-<left>") 'paredit-backward-slurp-sexp
    (kbd "C-<right>") 'paredit-forward-slurp-sexp
    (kbd "C-M-<left>") 'paredit-backward-barf-sexp
    (kbd "C-M-<right>") 'paredit-forward-barf-sexp)
  
  ;; Also for ClojureScript
  (evil-define-key 'insert clojurescript-mode-map
    (kbd "C-<left>") 'paredit-backward-slurp-sexp
    (kbd "C-<right>") 'paredit-forward-slurp-sexp
    (kbd "C-M-<left>") 'paredit-backward-barf-sexp
    (kbd "C-M-<right>") 'paredit-forward-barf-sexp)
  
  ;; And CIDER REPL
  (evil-define-key 'insert cider-repl-mode-map
    (kbd "C-<left>") 'paredit-backward-slurp-sexp
    (kbd "C-<right>") 'paredit-forward-slurp-sexp
    (kbd "C-M-<left>") 'paredit-backward-barf-sexp
    (kbd "C-M-<right>") 'paredit-forward-barf-sexp))
#+end_src

** TODO COMMENT Smartparens
Need to figure out what this does that is different from paredit.  infact i see the same bindings here that i see in paredit-mode

#+begin_src emacs-lisp 
;; (use-package smartparens
;;   :ensure nil 
;;   :config
;;   ;; Load the default configuration
;;   (require 'smartparens-config)
  
;;   ;; Enable smartparens in Python mode
;;   (add-hook 'python-mode-hook #'smartparens-mode)
  
;;   ;; Optional: Use strict mode for even better structural editing
;;   ;; (add-hook 'python-mode-hook #'smartparens-strict-mode)
  
;;   ;; Python-specific pairs
;;   (sp-local-pair 'python-mode "'" "'" :unless '(sp-in-comment-p sp-in-string-p))
;;   (sp-local-pair 'python-mode "\"" "\"" :unless '(sp-in-comment-p sp-in-string-p))
;;   (sp-local-pair 'python-mode "'''" "'''")
;;   (sp-local-pair 'python-mode "\"\"\"" "\"\"\"")
  
;;   ;; Useful keybindings for Python
;;   :bind (:map smartparens-mode-map
;;               ("C-M-f" . sp-forward-sexp)
;;               ("C-M-b" . sp-backward-sexp)
;;               ("C-<left>" . sp-backward-slurp-sexp)
;;               ("C-<right>" . sp-forward-slurp-sexp)
;;               ("C-M-<left>" . sp-backward-barf-sexp)
;; 	      ("C-M-<right>" . sp-forward-barf-sexp)
;;               ))

#+end_src

** Intelligent ripgrep
Place cursor at token and call C-. r for quick ripgrep using that token

#+begin_src emacs-lisp

;; Enhanced word/symbol extraction
(defun my/thing-at-point-or-region ()
  "Get either the selected region or symbol at point."
  (if (use-region-p)
      (buffer-substring-no-properties (region-beginning) (region-end))
    (thing-at-point 'symbol t)))

;; Main search functions
(defun my/consult-ripgrep-dwim ()
  "Search with consult-ripgrep using region or symbol at point."
  (interactive)
  (let ((query (my/thing-at-point-or-region)))
    (consult-ripgrep nil query)))

(defun my/embark-consult-ripgrep (str)
  "Search for STR using consult-ripgrep."
  (consult-ripgrep nil str))

(with-eval-after-load 'embark
  ;; Use the correct keymaps
  (define-key embark-symbol-map "r" 'my/embark-consult-ripgrep)
  (define-key embark-identifier-map "r" 'my/embark-consult-ripgrep)  ; This is the correct one
  (define-key embark-region-map "r" 'my/embark-consult-ripgrep))

(global-set-key (kbd "M-s R") 'my/consult-ripgrep-dwim)

#+end_src

* mu4e  - Basic Configuration
#+begin_src emacs-lisp
(message "Loading: Email - mu4e Basic Configuration")

(use-package mu4e
  :ensure nil  ;; Provided by Nix, no need to install via package.el
  :load-path "/nix/store/97ymyq978919zfqva4p15r4ddzzkkz0l-emacs-mu4e-1.12.7/share/emacs/site-lisp/elpa/mu4e-1.12.7"
  :config
  ;; Account settings
  (setq user-full-name "Ajaneesh Rajashekharaiah"
        user-mail-address "ajaneesh.rajashekharaiah@ihx.in"
        mu4e-maildir "~/Mail"
        mu4e-attachment-dir "~/Downloads")
  
  ;; Sending mail configuration
  (setq message-send-mail-function 'message-send-mail-with-sendmail
        send-mail-function 'message-send-mail-with-sendmail
        sendmail-program "/etc/profiles/per-user/nixos/bin/msmtp"
        message-sendmail-f-is-evil t
        message-sendmail-extra-arguments '("--read-envelope-from"))
  
  ;; Folder structure
  (setq mu4e-sent-folder "/[Gmail].Sent Mail"
        mu4e-drafts-folder "/[Gmail].Drafts"
        mu4e-trash-folder "/[Gmail].Bin"
        mu4e-refile-folder "/[Gmail].All Mail")
  
  ;; Shortcuts and mailbox sync
  (setq mu4e-maildir-shortcuts '(("/INBOX" . ?i) 
                                 ("/[Gmail].Sent Mail" . ?s))
        mu4e-get-mail-command "mbsync -a"
        mu4e-update-interval 300)
  
  ;; Signature
  (setq mu4e-compose-signature "-Ajaneesh"
        mu4e-compose-signature-auto-include t)
  
  ;; ┌────────────────────────────────────────────────────────────────┐
  ;; │                     Header View Configuration                   │
  ;; └────────────────────────────────────────────────────────────────┘
  
  ;; Headers appearance and behavior
  (setq mu4e-headers-fields '((:date . 12) 
                              (:flags . 6) 
                              (:from . 25) 
                              (:subject))
        mu4e-headers-date-format "%Y-%m-%d %H:%M"
        mu4e-headers-long-date-format "%Y-%m-%d %H:%M"
        mu4e-headers-time-format "%H:%M"
        mu4e-headers-visible-lines 15
        mu4e-headers-sort-direction 'descending
        mu4e-headers-search-skip-duplicates t
        mu4e-headers-skip-duplicates t
        mu4e-headers-include-related nil)
  
  ;; Use fancy characters in headers
  (setq mu4e-use-fancy-chars t
        mu4e-headers-draft-mark     '("D" . "🖊️")  ;; Draft
        mu4e-headers-flagged-mark   '("F" . "⚑")   ;; Flagged
        mu4e-headers-new-mark       '("N" . "✱")   ;; New
        mu4e-headers-passed-mark    '("P" . "➥")   ;; Passed/Forwarded
        mu4e-headers-replied-mark   '("R" . "↵")   ;; Replied
        mu4e-headers-seen-mark      '("S" . "✓")   ;; Seen
        mu4e-headers-trashed-mark   '("T" . "♻")   ;; Trashed
        mu4e-headers-attach-mark    '("a" . "📎")  ;; Attachment
        mu4e-headers-encrypted-mark '("x" . "🔒")  ;; Encrypted
        mu4e-headers-signed-mark    '("s" . "🔑")  ;; Signed
        mu4e-headers-unread-mark    '("u" . "●"))  ;; Unread

  ;; ┌────────────────────────────────────────────────────────────────┐
  ;; │                     Message View Configuration                  │
  ;; └────────────────────────────────────────────────────────────────┘
  
  ;; Message view settings
  (setq mu4e-view-fields '(:from :to :cc :subject :flags :date 
				 :maildir :mailing-list :tags 
				 :attachments :signature)
        mu4e-view-header-field-format "%s: %s\n"
        mu4e-view-header-separator (propertize "\n" 'face '(:background "gray90" :height 0.5))
        mu4e-view-show-addresses t
        mu4e-view-auto-mark-as-read t
        mu4e-split-view 'vertical
        mu4e-split-view-width 10
        mu4e-use-color t)
  
  ;; HTML rendering preferences
  (setq mu4e-view-prefer-html t
        mu4e-view-html-plaintext-ratio-heuristic most-positive-fixnum
        mu4e-view-show-images t
        mu4e-view-image-max-width 800)
  
  ;; Use xwidget webkit for HTML viewing if available
  (when (fboundp 'xwidget-webkit-browse-url)
    (setq mu4e-view-use-xwidget t))
  
  ;; ┌────────────────────────────────────────────────────────────────┐
  ;; │                   Message View Mode Hooks                       │
  ;; └────────────────────────────────────────────────────────────────┘
  
  ;; Set up improved appearance for message viewing
  (defun my/mu4e-view-mode-setup ()
    "Enhanced setup for mu4e-view-mode with better formatting and readability."
    ;; Use variable-pitch fonts for better readability
    (variable-pitch-mode 1)
    (setq line-spacing 0.1)
    (setq buffer-face-mode-face '(:family "Source Sans Pro" :height 110))
    (buffer-face-mode)
    
    ;; Activate olivetti mode for centered text
    (when (fboundp 'olivetti-mode)
      (olivetti-mode 1)
      (setq olivetti-body-width 90))
    
    ;; Ensure images are displayed
    (when (fboundp 'shr-toggle-images)
      (shr-toggle-images 1)))
  
  (add-hook 'mu4e-view-mode-hook 'my/mu4e-view-mode-setup)
  
  ;; HTML rendering settings
  (setq shr-color-visible-luminance-min 70
        shr-use-colors t
        shr-use-fonts t
        shr-max-width 90
        shr-discard-aria-hidden t))
#+end_src

* mu4e - Appearance and UI Enhancements

#+begin_src emacs-lisp

;; Header appearance with Modus themes
(with-eval-after-load 'modus-themes
  (setq modus-themes-mail-citations 'intense)  ;; Make citations more distinct
  (setq modus-themes-completions '((matches . (extrabold))
                                   (selection . (semibold accented))
                                   (popup . (accented intense))))
  
  ;; If using modus-vivendi (dark theme)
  (when (eq (modus-themes--current-theme) 'modus-vivendi)
    (set-face-attribute 'mu4e-header-highlight-face nil
                        :background (modus-themes-get-color-value 'bg-hl-alt)
                        :underline nil)))

;; Improve header appearance
(with-eval-after-load 'mu4e
  (set-face-attribute 'mu4e-header-face nil :family "Source Sans Pro" :height 90)
  (set-face-attribute 'mu4e-header-title-face nil :family "Source Sans Pro" :height 90)
  (set-face-attribute 'mu4e-header-key-face nil :family "Source Sans Pro" :height 90)
  (set-face-attribute 'mu4e-header-value-face nil :family "Source Sans Pro" :height 90)
  (set-face-attribute 'mu4e-contact-face nil :family "Source Sans Pro" :height 90))

(defun my/force-mu4e-use-xwidget ()
  "Force mu4e to use xwidget for HTML rendering."
  (when (fboundp 'xwidget-webkit-browse-url)
    (message "xwidget-webkit is available")
    (setq mu4e-view-prefer-html t)
    (setq mu4e-view-html-plaintext-ratio-heuristic most-positive-fixnum)
    (setq mu4e-view-use-xwidget t)
    (message "mu4e configured to use xwidget for HTML")))

(with-eval-after-load 'mu4e
  (my/force-mu4e-use-xwidget))

#+end_src

* mu4e - Notification and Alerts

#+begin_src emacs-lisp


;; Email notifications
(use-package mu4e-alert
  :ensure nil
  :after mu4e
  :config
  (mu4e-alert-set-default-style 'libnotify)
  (add-hook 'after-init-hook #'mu4e-alert-enable-notifications)
  (add-hook 'after-init-hook #'mu4e-alert-enable-mode-line-display))

#+end_src

* mu4e - org-mime integration for composition
** Hooks that could potentially interfere with org-message

#+begin_src emacs-lisp

;; ;; Automatically convert org buffer to HTML email when sending
;; (add-hook 'message-send-hook
;;           (lambda ()
;;             (when (and (eq major-mode 'org-mode)
;;                        (derived-mode-p 'message-mode)
;;                        (not (message-mail-p)))
;;               (org-mime-htmlize))))

;; ;;  Add keybinding to compose HTML email with Org
;; (with-eval-after-load 'mu4e
;;   (define-key mu4e-compose-mode-map (kbd "C-c M-h") 'org-mime-edit-mail-in-org-mode))

;; (add-hook 'message-send-hook 'org-mime-htmlize)
;; (add-hook 'message-send-hook 'org-mime-confirm-when-no-multipart)


#+end_src

** These should be safe to have even when org-msg is also configured and active

#+begin_src emacs-lisp

;; Org-mime for HTML email composition
(use-package org-mime
  :ensure nil
  :after (org mu4e)
  :config
  ;; Add a hook to convert org to HTML when sending
  (add-hook 'org-mime-html-hook
            (lambda ()
              (org-mime-change-element-style
               "pre" (format "color: %s; background-color: %s; padding: 0.5em;"
                             "#E6E1DC" "#232323"))))
  
  ;; Configure org-mime options
  (setq org-mime-export-options '(:section-numbers nil
						   :with-author nil
						   :with-toc nil
						   :with-latex nil))
  
  ;; Function to use HTML for HTML replies, text for text replies
  (setq org-mime-reply-function
        (lambda (msg)
          (if (string-match "text/html" (message-fetch-field "Content-Type"))
              (org-mime-htmlize)
            (message "Composing text-only reply"))))
  
  ;; Keybindings for converting between Org and HTML in emails
  (define-key message-mode-map (kbd "C-c M-o") 'org-mime-htmlize)
  (define-key org-mode-map (kbd "C-c M-o") 'org-mime-org-buffer-htmlize))


(setq org-latex-create-formula-image-program 'dvipng)
(setq org-preview-latex-default-process 'dvipng)
#+end_src

* mu4e - org-msg integration

#+begin_src emacs-lisp 

(use-package org-msg
  :ensure nil
  :init  ;; Use :init instead of :config to ensure it loads before mu4e uses it
  (setq org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:nil email:nil \\n:t"
        org-msg-startup "hidestars indent inlineimages"
        org-msg-default-alternatives '((new . (text html))
                                       (reply-to-html . (text html))
                                       (reply-to-text . (text html)))  ;; Always include HTML
        org-msg-convert-citation t
        org-msg-signature "

Regards,
Ajaneesh")
  (org-msg-mode 1))

(with-eval-after-load 'mu4e
  ;; Tell mu4e to use org-msg for composition
  (setq mu4e-compose-format-flowed t)

  (require 'org-msg)
  (org-msg-mode 1) 
  
  ;; Make sure org-msg uses your HTML viewing preferences
  (when (fboundp 'xwidget-webkit-browse-url)
    (setq mu4e-view-use-xwidget t)
    (setq org-msg-enforce-css
          (concat "blockquote {border-left: 4px solid #ccc; padding-left: 10px;}\n"
                  "code {background-color: #f9f9f9; padding: 2px 4px; border-radius: 3px;}\n"
                  "pre {background-color: #f9f9f9; padding: 8px; border-radius: 3px; overflow: auto;}")))
                  
  ;; Optional: Customize the CSS for HTML emails
  (setq org-msg-enforce-css
      "pre {font-family: monospace; font-size: 90%; overflow: auto; margin: 0.8em; padding: 0.5em; background-color: #f5f5f5;}
       .src {background-color: #f5f5f5; padding: 8px;}
       blockquote {border-left: 4px solid #ddd; padding: 0 15px; color: #777;}
       .quote {color: #777;}
       .timestamp {color: #999;}
       h1,h2,h3,h4,h5,h6 {font-family: Arial, sans-serif; color: #333;}
       li {margin: 0.5em 0;}
       a {color: #0066cc; text-decoration: none;}
       a:hover {text-decoration: underline;}
       p {margin: 0.5em 0;}"))
(setq org-msg-enforce-css
      (concat org-msg-enforce-css
              "pre.src {background-color: #282c34; color: #bbc2cf; padding: 0.5em;}")
      org-msg-startup "hidestars indent inlineimages")

(add-hook 'mu4e-compose-mode-hook 'org-msg-mode)
(add-hook 'mu4e-compose-pre-hook 'org-msg-mode)

(setq org-msg-default-alternatives '((new . (text html))
                                     (reply-to-html . (text html))
                                     (reply-to-text . (text html))))

(setq org-msg-options "html-postamble:nil H:5 num:nil ^:{} toc:nil author:nil email:nil \\n:t tex:t")

;; For multiple templates related to email

;; Capture message links
(defun my/capture-mail-follow (msg)
  (when (eq major-mode 'mu4e-view-mode)
    (mu4e-view-message-action 'capture)))

(add-hook 'org-capture-mode-hook 'my/capture-mail-follow)

(remove-hook 'mu4e-compose-mode-hook 'org-msg-mode)  ;; Remove potentially duplicate hook
(add-hook 'mu4e-compose-pre-hook
          (lambda ()
            (org-msg-mode 1)
            (message "org-msg activated for composition")))
#+end_src

** mu4e - toggle between mime and msg packages for org/html support

#+begin_src emacs-lisp 

;; (defun my/toggle-org-msg-mode ()
;;   "Toggle between org-msg and standard composition."
;;   (interactive)
;;   (if org-msg-mode
;;       (progn
;;         (org-msg-mode -1)
;;         (message "Standard email composition enabled"))
;;     (org-msg-mode 1)
;;     (message "Org-msg HTML composition enabled")))

;; (with-eval-after-load 'mu4e
;;   (define-key mu4e-headers-mode-map (kbd "C-c m") 'my/toggle-org-msg-mode)
;;   (define-key mu4e-view-mode-map (kbd "C-c m") 'my/toggle-org-msg-mode))

#+end_src

* mu4e - Enhacement Packages

#+begin_src emacs-lisp

;; Use emojis in emails - using built-in emoji support instead of emojify
;; (use-package emojify
;;   :ensure t
;;   :hook (mu4e-view-mode . emojify-mode))

;; Enable emoji rendering in mu4e using built-in support
(add-hook 'mu4e-view-mode-hook
          (lambda ()
            (when (fboundp 'emoji-mode)
              (emoji-mode 1))))

;; Centered reading with Olivetti
(use-package olivetti
  :ensure nil
  :config
  (setq olivetti-body-width 90)
  (setq olivetti-minimum-body-width 70)
  (setq olivetti-recall-visual-line-mode-entry-state t))

;; Icons in completion
(use-package all-the-icons
  :ensure nil)

(use-package all-the-icons-completion
  :ensure nil
  :after (marginalia all-the-icons)
  :hook (marginalia-mode . all-the-icons-completion-marginalia-setup))

#+end_src

* mu4e - Convenience Functions

#+begin_src emacs-lisp

;; Function to toggle between HTML and plain text view
(defun my/toggle-html-plain-text ()
  "Toggle between HTML and plain text view in mu4e."
  (interactive)
  (if (bound-and-true-p mu4e-view-prefer-html)
      (progn
        (setq mu4e-view-prefer-html nil)
        (message "Switched to plain text view"))
    (setq mu4e-view-prefer-html t)
    (message "Switched to HTML view"))
  (mu4e-view-refresh))

;; Add the toggle command to mu4e-view-mode-map
(with-eval-after-load 'mu4e-view
  (define-key mu4e-view-mode-map (kbd "C-c t") 'my/toggle-html-plain-text))
#+end_src

* mixed-pitch-mode configuration for org-mode

#+begin_src emacs-lisp

;; Configure mixed-pitch mode for Org
(use-package mixed-pitch
  :hook
  (org-mode . mixed-pitch-mode)
  :config
  (setq mixed-pitch-set-height t)
  ;; Keep code blocks, tables, etc in fixed-pitch
  (setq mixed-pitch-fixed-pitch-faces
        '(org-block
          org-block-begin-line
          org-block-end-line
          org-code
          org-document-info-keyword
          org-meta-line
          org-property-value
          org-special-keyword
          org-table
          org-verbatim
          line-number
          line-number-current-line)))

#+end_src

* Font and Color Configuration

#+begin_src emacs-lisp
(message "Loading: Font and Color Configuration")

;; Basic font definitions - KEEP THESE
(set-face-attribute 'default nil
                    :family "JetBrains Mono"
                    :height 90)

(set-face-attribute 'fixed-pitch nil 
                    :family "JetBrains Mono"
                    :height 90)

(set-face-attribute 'variable-pitch nil
                    :family "Source Sans Pro"
                    :height 110)

;; Ligature config - KEEP THIS
(use-package ligature
  :ensure nil
  :config
  (ligature-set-ligatures 't '("www" "**" "***" "**/" "*>" "*/" "\\\\" "\\\\\\"
                               "{-" "::" ":::" ":=" "!!" "!=" "!==" "-}" "--" "---" "-->"
                               "->>" "->" "-<" "-<<" "-~" "#{" "#[" "##" "###" "####"
                               "#(" "#?" "#_" "#_(" ".-" ".=" ".." "..<" "..." "?="))
  (global-ligature-mode t))

;; ==== NEW CENTRALIZED CONFIGURATION ====

(defun my/apply-fonts-and-faces ()
  "Apply centralized font and face settings, using Modus theme colors."
  (interactive)
  
  ;; Define our font families
  (let* ((fixed-font "JetBrains Mono")
         (variable-font "Source Sans Pro")
         (code-font-size 90)
         (ui-font-size 120)
         
         ;; Variable tuple for org headings
         (variable-tuple
          (cond ((x-list-fonts variable-font) `(:font ,variable-font))
                ((x-list-fonts "Lucida Grande") '(:font "Lucida Grande"))
                ((x-list-fonts "Verdana") '(:font "Verdana"))
                ((x-family-fonts "Sans Serif") '(:family "Sans Serif"))
                (nil (warn "Cannot find a Sans Serif Font."))))
         
         ;; Get base color from current theme
         (base-font-color (face-foreground 'default nil 'default))
         (headline `(:inherit default :foreground (modus-themes-get-color-value 'fg-main))))
    
    ;; ===== ORG MODE FACES =====
    (with-eval-after-load 'org
      (custom-theme-set-faces
       'user
       ;; Fixed-pitch elements
       `(org-block ((t (:inherit fixed-pitch))))
       `(org-code ((t (:inherit (shadow fixed-pitch)))))
       `(org-document-info-keyword ((t (:inherit (shadow fixed-pitch)))))
       `(org-indent ((t (:inherit (org-hide fixed-pitch)))))
       `(org-meta-line ((t (:inherit (font-lock-comment-face fixed-pitch)))))
       `(org-property-value ((t (:inherit fixed-pitch))))
       `(org-special-keyword ((t (:inherit (font-lock-comment-face fixed-pitch)))))
       `(org-table ((t (:inherit fixed-pitch :foreground ,(modus-themes-get-color-value 'blue-alt)))))
       `(org-tag ((t (:inherit (shadow fixed-pitch) :weight normal :height 0.8))))
       `(org-verbatim ((t (:inherit (shadow fixed-pitch)))))
       
       ;; Document structure with variable pitch
       `(org-document-title ((t (:inherit default ,@variable-tuple :height 2.0 :underline nil))))
       `(org-level-1 ((t (,@headline ,@variable-tuple))))
       `(org-level-2 ((t (,@headline ,@variable-tuple))))
       `(org-level-3 ((t (,@headline ,@variable-tuple))))
       `(org-level-4 ((t (,@headline ,@variable-tuple))))
       `(org-level-5 ((t (,@headline ,@variable-tuple))))
       `(org-level-6 ((t (,@headline ,@variable-tuple))))
       `(org-level-7 ((t (,@headline ,@variable-tuple))))
       `(org-level-8 ((t (,@headline ,@variable-tuple))))
       
       ;; Links and other elements
       `(org-link ((t (:foreground ,(modus-themes-get-color-value 'blue) :underline t)))))))

  ;; ===== TREEMACS FACES =====
  (with-eval-after-load 'treemacs
    ;; Make sure all files have at least a fallback icon
    (treemacs-define-custom-icon 
     (all-the-icons-faicon "file-o" :v-adjust 0.0 :height 0.8)
     "fallback")
    (custom-theme-set-faces
     'user
     `(treemacs-root-face ((t (:inherit variable-pitch :height 0.9))))
     `(treemacs-file-face ((t (:inherit variable-pitch :height 0.9))))
     `(treemacs-directory-face ((t (:inherit variable-pitch :height 0.9))))
     `(treemacs-git-modified-face ((t (:inherit variable-pitch :height 0.9))))
     `(treemacs-git-untracked-face ((t (:inherit variable-pitch :height 0.9))))))
  
  ;; ===== MU4E FACES =====
  (with-eval-after-load 'mu4e
    (custom-theme-set-faces
     'user
     `(mu4e-header-face ((t (:family ,variable-font :height 90))))
     `(mu4e-header-title-face ((t (:family ,variable-font :height 90))))
     `(mu4e-header-key-face ((t (:family ,variable-font :height 90))))
     `(mu4e-header-value-face ((t (:family ,variable-font :height 90))))
     `(mu4e-contact-face ((t (:family ,variable-font :height 90))))
     `(mu4e-highlight-face ((t (:background ,(modus-themes-get-color-value 'bg-active)
                                            :foreground ,(modus-themes-get-color-value 'fg-main)))))
     `(mu4e-header-highlight-face ((t (:background ,(modus-themes-get-color-value 'bg-hl-alt)
                                                   :underline nil))))))
  
  (message "Applied centralized font and face settings"))

;; Update your mu4e buffer-local theme to use Modus colors
(defun my/apply-mu4e-buffer-local-theme ()
  "Apply buffer-local light theme for mu4e using Modus Operandi colors."
  (when (derived-mode-p 'mu4e-view-mode 'mu4e-compose-mode)
    ;; Ensure we're working with buffer-local faces
    (buffer-face-mode 1)
    
    ;; Store the current theme
    (let ((current-theme (car custom-enabled-themes))
          (temp-theme nil))
      
      ;; Temporarily load modus-operandi if not already active
      (unless (eq current-theme 'modus-operandi)
        (load-theme 'modus-operandi t)
        (setq temp-theme 'modus-operandi))
      
      ;; Apply face remappings using Modus Operandi colors
      (face-remap-add-relative 'default 
                               :background (modus-themes-get-color-value 'bg-main)
                               :foreground (modus-themes-get-color-value 'fg-main))
      
      (face-remap-add-relative 'fringe 
                               :background (modus-themes-get-color-value 'bg-dim))
      
      (face-remap-add-relative 'mu4e-header-face 
                               :foreground (modus-themes-get-color-value 'fg-dim))
      
      (face-remap-add-relative 'mu4e-unread-face 
                               :foreground (modus-themes-get-color-value 'blue-warmer)
                               :weight 'bold)
      
      (face-remap-add-relative 'mu4e-highlight-face 
                               :background (modus-themes-get-color-value 'bg-active)
                               :foreground (modus-themes-get-color-value 'fg-main))
      
      (face-remap-add-relative 'mu4e-header-highlight-face 
                               :background (modus-themes-get-color-value 'bg-hl-alt))
      
      (face-remap-add-relative 'mode-line 
                               :background (modus-themes-get-color-value 'bg-mode-line-active)
                               :foreground (modus-themes-get-color-value 'fg-mode-line-active))
      
      (face-remap-add-relative 'mode-line-inactive 
                               :background (modus-themes-get-color-value 'bg-mode-line-inactive)
                               :foreground (modus-themes-get-color-value 'fg-mode-line-inactive))
      
      ;; Text rendering adjustments (only font family/size, no colors)
      (face-remap-add-relative 'variable-pitch :family "Source Sans Pro" :height 110)
      
      ;; Restore original theme if we temporarily changed it
      (when temp-theme
        (disable-theme temp-theme)
        (when current-theme
          (enable-theme current-theme))))))

;; Add hooks for mu4e buffer-local themes
;; (with-eval-after-load 'mu4e
;;   (add-hook 'mu4e-view-mode-hook 'my/apply-mu4e-buffer-local-theme)
;;   (add-hook 'mu4e-compose-mode-hook 'my/apply-mu4e-buffer-local-theme))

;; Modify your modus-themes configuration
(use-package modus-themes
  :ensure nil
  :config
  ;; Your existing settings...
  (setq modus-themes-mode-line '(accented borderless)
        modus-themes-bold-constructs t
        modus-themes-italic-constructs t
        modus-themes-fringes 'subtle
        modus-themes-tabs-accented t
        modus-themes-paren-match '(bold intense)
        modus-themes-prompts '(bold intense)
        modus-themes-completions '((matches . (extrabold underline))
  				   (selection . (semibold)))
        modus-themes-org-blocks 'tinted-background
        modus-themes-scale-headings t
        modus-themes-region '(bg-only)
        modus-themes-headings
        '((1 . (rainbow regular overline background 1.0))
          (2 . (rainbow regular background 1.0))
          (3 . (rainbow regular 1.0))
          (t . (semilight 1.0))))

  ;; Add our function to the theme loading hook
  (add-hook 'modus-themes-after-load-theme-hook #'my/apply-fonts-and-faces)
  
  ;; Load theme - this will trigger our hook
  (load-theme 'modus-vivendi t ))

;; Add a theme toggle function
(defun my/toggle-modus-theme ()
  "Toggle between light and dark Modus themes."
  (interactive)
  (if (eq (car custom-enabled-themes) 'modus-operandi)
      (load-theme 'modus-vivendi t) 
    (load-theme 'modus-operandi t)))

;; Key binding for toggling themes - currently conflicting with treemacs
;; (global-set-key (kbd "C-c t t") 'my/toggle-modus-theme)




#+end_src

* Global Configuration

#+begin_src emacs-lisp

;; ESC cancels all
(global-set-key (kbd "<escape>") 'keyboard-escape-quit)
(global-set-key [C-tab] 'other-window)

;; Prevent auto-centering
(setq scroll-conservatively 101)


(global-set-key [f5] 'revert-buffer)
(global-set-key (kbd "C-!") 'eval-expression)

#+end_src

** Focus on one window by toggling its full-screen view using F12

Hitting F12 hides other windows (except treemacs).  Any number of other windows may be open.  It will restore other buffers back when toggled.  But restoration only works till any actions are executed.  To be used only in context where you are peeking at something like a log file which is wrapping which would momentarily benefit from full screen view. 

#+begin_src emacs-lisp

  (defvar my/saved-window-config nil 
    "Store window configuration for maximize/restore.")

  (defun my/maximize-window ()
    "Maximize current window, keeping config for restore."
    (interactive)
    (if my/saved-window-config
        (progn
          (set-window-configuration my/saved-window-config)
          (setq my/saved-window-config nil)
          (message "Layout restored"))
      (setq my/saved-window-config (current-window-configuration))
      (delete-other-windows)
      (message "Window maximized - run command again to restore")))

  ;; Bind to a key of your choice later
  (global-set-key (kbd "<f12>") 'my/maximize-window)
  
#+end_src

** Use standard windows shortcut to close tabs for quickly killing buffers

Ctrl-K and RETURN would also do the same thing.  but i find this convenient and i use this as it matches with tab closing keymap in windows text editors. 

#+begin_src emacs-lisp

  (defun my/kill-current-buffer ()
    "Kill current buffer without confirmation."
    (interactive)
    (kill-buffer (current-buffer)))

  (global-set-key [C-f4] 'my/kill-current-buffer)

#+end_src

** Cycle through programming mode output buffers quickly using F6
This takes a list of regexp that identify buffers to cycle through.  useful for quickly getting to python compilation and clojure REPL buffers.  *I hardly ever use this as i end up opening way to many buffers of source files and it makes no sense to cycle through all of them* 

#+begin_src emacs-lisp
  (defun my/cycle-output-buffers ()
    "Cycle through compilation, cider and repl buffers."
    (interactive)
    (let* ((buffer-patterns '("\\*compilation\\*"
                              "\\*cider\\-repl.*\\*"
                              "\\*repl.*\\*"))
           ;; Get list of matching buffers
           (matching-buffers
            (seq-filter
             (lambda (buf)
               (let ((buf-name (buffer-name buf)))
                 (seq-some (lambda (pattern)
                             (string-match-p pattern buf-name))
                           buffer-patterns)))
             (buffer-list)))
           ;; Sort them by name for consistent cycling
           (sorted-buffers (sort matching-buffers
                                 (lambda (a b)
                                   (string< (buffer-name a)
                                            (buffer-name b)))))
           ;; Find current buffer's position
           (current-pos (seq-position sorted-buffers (current-buffer)))
           (num-buffers (length sorted-buffers)))
      
      (cond
       ((null sorted-buffers)
        (message "No matching buffers found"))
       ((null current-pos)
        ;; If current buffer isn't in the list, switch to first matching buffer
        (switch-to-buffer (car sorted-buffers)))
       (t
        ;; Switch to next buffer in cycle
        (switch-to-buffer
         (nth (mod (1+ current-pos) num-buffers)
              sorted-buffers))))))

  ;; Bind to F6
  (global-set-key [f6] 'my/cycle-output-buffers)
#+end_src

** Copy buffer message.
Useful stuff.  this is to avoid having to go to the Messages buffer to copy.  I use this mostly to query copilots for fixes as the last error that is flashed in mini buffer is usually the thing we use to research or debug
*This is not working anymore. It usually changes the buffer message as soon as C-c is hit.  It still copies text.  But some other useless nonsense*  The idea was to use this to copy file paths when navigating treemacs.  Treemacs usually shows the entire file path in the minibuffer
#+begin_src emacs-lisp

  (defvar my/last-minibuffer-message nil)

  (advice-add 'message :after 
              (lambda (&rest args)
                (when (car args)
                  (setq my/last-minibuffer-message (apply #'format-message args)))))

  (global-set-key (kbd "C-c w") (lambda () 
    				(interactive)
    				(when my/last-minibuffer-message
    				  (kill-new my/last-minibuffer-message)
    				  (let ((message-log-max nil)) ; prevent recursive message capture
    				    (message "Copied: %s" my/last-minibuffer-message)))))
#+end_src

** Custom editor file cycling for prog-mode
use F8 to cycle through open buffers matching the file extension of the current buffer. This is useful when you have some 4-5 py or clj files open and you want to find one of them by using a single key. probably not very useful in cases when too many such buffers are open unless we can get a completion popup.  that is the next step in the evolution of this customization
The grand plan is to get a popup completion so that a file can be picked,  that is still work in progress, even now it only toggles
between the open files which is ok when there aren't too many files open

#+begin_src emacs-lisp

(defun my/get-buffer-extension (&optional buffer)
  "Get the file extension of BUFFER or current buffer."
  (when-let* ((buffer (or buffer (current-buffer)))
              (file-name (buffer-file-name buffer)))
    (file-name-extension file-name)))

(defun my/cycle-same-extension-buffers (&optional reverse)
  "Cycle through buffers with same extension as current buffer."
  (interactive)
  (when (derived-mode-p 'prog-mode)
    (let* ((curr-ext (my/get-buffer-extension))
           (current-buf (current-buffer))
           ;; Get all matching buffers and sort them by name
           (same-ext-buffers
            (sort 
             (seq-filter
              (lambda (buf)
                (with-current-buffer buf
                  (and (buffer-file-name buf)
                       (derived-mode-p 'prog-mode)
                       (when-let ((ext (my/get-buffer-extension buf)))
                         (string= ext curr-ext)))))
              (buffer-list))
             (lambda (a b) 
               (string< (buffer-name a) (buffer-name b)))))
           ;; Find current position
           (current-index (cl-position current-buf same-ext-buffers))
           (total (length same-ext-buffers)))
      
      (when (and current-index (> total 1))
        ;; Calculate next position with wrapping
        (let* ((next-index (if reverse
                               (if (= current-index 0) 
                                   (1- total) 
                                 (1- current-index))
                             (if (= current-index (1- total)) 
                                 0 
                               (1+ current-index))))
               (next-buf (nth next-index same-ext-buffers)))
          
          ;; Switch buffer with messages suppressed
          (let ((inhibit-message t))
            (switch-to-buffer next-buf)
            ;; Show simple status message
            (message "[%d/%d] %s" 
                     (1+ next-index) 
                     total
                     (buffer-name next-buf))))))))

(defun my/cycle-same-extension-buffers-backward ()
  "Cycle through buffers with same extension as current buffer backwards."
  (interactive)
  (my/cycle-same-extension-buffers t))

;; Bind to F8 and Shift-F8
(define-key prog-mode-map [f8] 'my/cycle-same-extension-buffers)

#+end_src

** For one off updates in existing buffers
This is something that i use often.  it kind of makes it easier to deal with =lsp-find-references= and =lsp-find-definiton= when looking at code.  I can use a single key in most cases to navigate back and forth betwen caller and callee. Works especially well when there is a single caller, it simply toggles between the references.  When there is more than once reference, then it works a little like ripgrep.   

#+begin_src emacs-lisp

;; Define the smart reference finder
(defun my/smart-find-references ()
  "Enhanced reference finder using xref (works with Eglot)."
  (interactive)
  ;; Use xref-find-references which works with Eglot
  ;; xref provides the same functionality with a built-in interface
  (call-interactively 'xref-find-references))

;; F4 binding is now handled in the main Python keybinding section above

#+end_src

* SQL Client configuration
makes it easier to open a connection to Postgres.   In this setup, i save my connection properties in a .config/.. file and when i start a connection with =C-c s c=, i am prompted for a password and hitting =C-c s p= automatically enters the password from my secrets file. Having to do this as the connection routinue is not accepting password even if supplied along with other connection parameters. 
#+begin_src emacs-lisp

;; Declare SQL variables as dynamic to avoid lexical binding conflicts
(defvar sql-user nil)
(defvar sql-password nil) 
(defvar sql-server nil)
(defvar sql-database nil)
(defvar sql-port nil)
(defvar sql-product nil)
(defvar sql-postgres-program nil)
(defvar sql-postgres-options nil)

;; Function to read from secrets.json
(defun my/read-postgres-secrets ()
  "Read PostgreSQL connection details from secrets.json"
  (let* ((json-object-type 'hash-table)
         (json-array-type 'list)
         (json-key-type 'string)
         (secrets-file (expand-file-name "~/.config/ihx/secrets.json"))
         (json-data (with-temp-buffer
                      (insert-file-contents secrets-file)
                      (json-read-from-string (buffer-string)))))
    (list :user (gethash "db_user" json-data)
          :database (gethash "db_name" json-data)
          :server (gethash "db_host_local" json-data)
          :port (let ((port-value (gethash "db_port_local" json-data)))
                  (if (stringp port-value) 
                      (string-to-number port-value) 
                    port-value))
          :password (gethash "db_password" json-data))))

(defun my/postgres-connect ()
  "Connect to PostgreSQL using settings from secrets file."
  (interactive)
  ;; Get connection details and set SQL variables dynamically
  (let ((pg-conn (my/read-postgres-secrets)))
    (setq sql-postgres-program "psql"
          sql-postgres-options '("-P" "pager=off")
          sql-product 'postgres
          sql-user (plist-get pg-conn :user)
          sql-password (plist-get pg-conn :password)
          sql-server (plist-get pg-conn :server)
          sql-database (plist-get pg-conn :database)
          sql-port (plist-get pg-conn :port))
    
    ;; Override password handling to prevent prompting
    (advice-add 'sql-get-login :around
                (lambda (orig-fun &rest args)
                  (let ((func (nth 0 args))
                        (prompt (nth 1 args))
                        (default (nth 2 args)))
                    (if (and (eq func 'sql-password)
                             (or (string= prompt "Password: ")
                                 (string= prompt "PostgreSQL Password: ")))
                        sql-password
                      (apply orig-fun args))))
                '((name . password-override)))
    
    ;; Create a buffer name based on connection details
    (let ((sql-buffer (sql-postgres)))
      ;; After connection, set up buffer for SQL sending
      (with-current-buffer sql-buffer
        (setq-local sql-buffer sql-buffer))
      
      ;; Return to the previous buffer and set sql-buffer there too
      (with-current-buffer (other-buffer sql-buffer 1)
        (when (eq major-mode 'sql-mode)
          (setq-local sql-buffer sql-buffer)))
      
      ;; Remove advice
      (advice-remove 'sql-get-login 'password-override))))

(defun my/insert-pg-password ()
  "Insert PostgreSQL password from secrets at current position.
If in minibuffer during password prompt, inserts and submits."
  (interactive)
  (let* ((pg-conn (my/read-postgres-secrets))
         (password (plist-get pg-conn :password))
         (in-minibuffer (minibufferp)))
    ;; Store in kill ring
    (kill-new password)
    
    ;; Insert password
    (insert password)
    
    ;; If in minibuffer, automatically submit
    (when in-minibuffer
      (exit-minibuffer))
    
    (message "PostgreSQL password %s." 
             (if in-minibuffer "submitted" "inserted"))))


;; Configure which-key to show a descriptive prefix for your SQL keys
(which-key-add-key-based-replacements
  "C-c s" "sql")

;; You can also add descriptions for the individual commands
(which-key-add-key-based-replacements
  "C-c s c" "connect"
  "C-c s p" "password from secrets")

(global-set-key (kbd "C-c s c") 'my/postgres-connect)
(global-set-key (kbd "C-c s p") 'my/insert-pg-password)

;; Setup SQL file keybindings
(with-eval-after-load 'sql
  (define-key sql-mode-map (kbd "C-c C-c") 'sql-send-paragraph))

#+end_src

* Claude Code Integration

Claude Code integration using the dedicated claude-code.el package for better Emacs integration.

#+begin_src emacs-lisp
;; -*- lexical-binding: t; -*-
;; Claude Code Emacs Integration using claude-code.el
;; This uses the dedicated Emacs package: https://github.com/stevemolitor/claude-code.el

;; First, ensure we have the required dependencies
(use-package transient
  :ensure nil) ; Should already be available in modern Emacs

(use-package eat
  :ensure nil) ; Terminal emulator for Claude Code

;; Configure claude-code.el
(use-package claude-code
  :ensure nil ; Already installed via package-vc-install above
  :bind-keymap
    ("C-c c" . claude-code-command-map)
    :config
    (claude-code-mode)) 

#+end_src
 
